# US 퀀트 시스템 지표 개선 계획서

**작성일:** 2026-01-17
**목적:** VaR 정확도 향상, final_score 예측력 개선, 등급 시스템 최적화

---

## 1. 현황 및 문제점

### 1.1 현재 VaR 계산 방식

```python
# us_main.py:759-790
# Historical Simulation: 252일간 일별 수익률의 5th percentile
returns = [(prices[i] - prices[i-1]) / prices[i-1] * 100 for i in range(1, len(prices))]
var_95 = np.percentile(returns, 5)  # 1일 VaR
```

### 1.2 VaR 문제점

| 문제 | 현재 상태 | 영향 |
|------|----------|------|
| 기간 불일치 | 1일 VaR로 90일 수익률 검증 | 초과율 41.53% (목표 5%) |
| 스케일링 없음 | 1일 → 90일 변환 미적용 | 리스크 8배 과소평가 |
| Fat tail 미반영 | 단순 Historical | 극단적 손실 예측 부정확 |
| 단일 기간 | var_95 하나만 계산 | 다양한 보유 기간 대응 불가 |

### 1.3 final_score 문제점

| 문제 | 현재 상태 | 영향 |
|------|----------|------|
| Monotonicity -1.0 | 매도 등급이 최고 수익률 | 등급 신뢰도 저하 |
| Momentum IC = 0.006 | 예측력 거의 없음 | 가중치 25%가 노이즈 |
| 단순 점수 구간 | 필터 없이 점수만으로 등급 | 극단적 오류 가능 |
| Nano Cap 바이오텍 | 매도 등급에서 급등 | Hit Rate 왜곡 |

### 1.4 개선 목표

- VaR 초과율: 41.53% → 8% 이하
- Grade Monotonicity: -1.0 → +0.5 이상
- 매도 등급 Hit Rate: 현재 (잘못됨) → 50% 이상 (정방향)
- 기간별 VaR 제공: 5일, 20일, 60일, 90일

---

## 2. Phase 1: VaR 시스템 개선

### 2.1 Hurst Exponent 기반 VaR 스케일링

#### 개념

```
H > 0.5: Trending (추세 지속) → 리스크가 sqrt(T)보다 빠르게 증가
H = 0.5: Random Walk (정규분포) → 리스크가 sqrt(T)로 증가
H < 0.5: Mean Reverting (평균 회귀) → 리스크가 sqrt(T)보다 느리게 증가

VaR 스케일링: VaR_T = VaR_1 * T^H
```

#### 구현 함수

```python
def calculate_hurst_exponent(returns: np.ndarray, min_chunk: int = 8) -> float:
    """
    R/S (Rescaled Range) Analysis로 Hurst Exponent 계산

    Args:
        returns: 일별 수익률 배열 (최소 100일 권장)
        min_chunk: 최소 청크 크기

    Returns:
        H: Hurst exponent (0 < H < 1)
    """
    N = len(returns)
    if N < min_chunk * 4:
        return 0.5  # 데이터 부족 시 기본값

    chunk_sizes = []
    rs_values = []

    for chunk_size in range(min_chunk, N // 4):
        rs_list = []

        for start in range(0, N - chunk_size + 1, chunk_size):
            chunk = returns[start:start + chunk_size]
            mean_adj = chunk - np.mean(chunk)
            cumsum = np.cumsum(mean_adj)
            R = np.max(cumsum) - np.min(cumsum)
            S = np.std(chunk, ddof=1)

            if S > 0:
                rs_list.append(R / S)

        if rs_list:
            chunk_sizes.append(chunk_size)
            rs_values.append(np.mean(rs_list))

    if len(chunk_sizes) < 3:
        return 0.5

    log_n = np.log(chunk_sizes)
    log_rs = np.log(rs_values)
    slope, _ = np.polyfit(log_n, log_rs, 1)

    return max(0.1, min(0.9, slope))


def calculate_var_scaled(var_1d: float, target_days: int, hurst: float) -> float:
    """
    Hurst exponent 기반 VaR 스케일링

    Args:
        var_1d: 1일 VaR (%, 양수)
        target_days: 목표 기간 (5, 20, 60, 90일)
        hurst: Hurst exponent

    Returns:
        var_Td: T일 VaR (%, 양수)
    """
    scale_factor = target_days ** hurst
    var_Td = var_1d * scale_factor
    return round(var_Td, 2)
```

#### 예시 계산

```
종목 A (추세 지속형):
- 1일 VaR = 3.5%
- Hurst = 0.55
- 90일 VaR = 3.5% * 90^0.55 = 3.5% * 12.73 = 44.6%

종목 B (평균 회귀형):
- 1일 VaR = 3.5%
- Hurst = 0.45
- 90일 VaR = 3.5% * 90^0.45 = 3.5% * 7.55 = 26.4%

비교 (sqrt(T) 방식):
- 90일 VaR = 3.5% * sqrt(90) = 3.5% * 9.49 = 33.2%
```

### 2.2 추가 컬럼 (us_stock_grade 테이블)

```sql
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS hurst_exponent DECIMAL(5,4);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_95_5d DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_95_20d DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_95_60d DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_95_90d DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_99 DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS var_99_90d DECIMAL(6,2);
```

### 2.3 EWMA 변동성 기반 VaR (옵션)

```python
async def calculate_var_95_ewma(self, lambda_param: float = 0.94) -> Optional[float]:
    """
    EWMA (Exponentially Weighted Moving Average) 변동성 기반 VaR

    최근 데이터에 더 높은 가중치를 부여하여 변동성 클러스터링 반영
    """
    # EWMA Variance
    ewma_var = returns[0] ** 2
    for r in returns[1:]:
        ewma_var = lambda_param * ewma_var + (1 - lambda_param) * (r ** 2)

    ewma_vol = np.sqrt(ewma_var) * 100

    # VaR 95% (assuming normal distribution)
    var_95 = 1.645 * ewma_vol  # 양수로 저장

    return round(var_95, 2)
```

---

## 3. Phase 2: Momentum 조건부 중립화

### 3.1 문제 분석

현재 Momentum Factor:
- 90일 IC = 0.006 (거의 예측력 없음)
- ICIR = 0.41 (신호 대 잡음비 낮음)
- Hit Rate = 66% (안정성 낮음)

### 3.2 해결책: 가중치 0%가 아닌 50점 중립화

**왜 0%가 문제인가:**

```
가중치 재분배 시:
Momentum 25% → 0%
다른 팩터: 25% → 33.3%

결과: 동일 종목이 "중립" → "매수 고려"로 변경 가능
```

**50점 중립화 방식:**

```python
def get_neutralized_scores(self, scores: dict, momentum_ic: float) -> dict:
    """
    IC가 낮은 팩터를 50점으로 중립화

    Args:
        scores: {'value': float, 'momentum': float, ...}
        momentum_ic: 현재 momentum factor IC

    Returns:
        dict: 중립화 적용된 scores
    """
    neutralized = scores.copy()

    # Momentum IC < 0.03이면 중립화
    if abs(momentum_ic) < 0.03:
        neutralized['momentum'] = 50.0

    return neutralized
```

**효과 검증:**

```
종목 A: value=80, quality=30, momentum=30, growth=80
가중치: (0.25, 0.25, 0.25, 0.25)

기존: 0.25*80 + 0.25*30 + 0.25*30 + 0.25*80 = 55.0 (중립)
중립화: 0.25*80 + 0.25*30 + 0.25*50 + 0.25*80 = 60.0 (매수 고려)

→ momentum이 30→50으로 상승하여 점수 증가
→ 하지만 다른 팩터가 과대평가되지 않음
→ 100점 만점 스케일 유지
```

### 3.3 시장 상태별 조건부 중립화 (고급)

한국 시스템 참고:

```python
MOMENTUM_NEUTRALIZE_CONDITIONS = [
    '모멘텀형',      # 이미 모멘텀으로 분류된 종목
    '역발상',        # 역발상 종목에서 순방향 모멘텀은 역효과
    '과열',          # 과열 시장에서 모멘텀 평균회귀
]

QUALITY_NEUTRALIZE_CONDITIONS = [
    '침체', '공포',  # 침체/공포 시장에서 quality 무의미
    '역발상',        # 역발상 전략에서 quality 역효과
    '탐욕', '과열',  # 투기 시장에서 quality 무시됨
]
```

---

## 4. Phase 3: 등급 시스템 최적화

### 4.1 현재 문제

```python
# 현재 us_main.py 방식: 단순 점수 구간
GRADE_THRESHOLDS = {
    '강력 매수': 85,
    '매수': 75,
    '매수 고려': 65,
    '중립': 55,
    '매도 고려': 45,
    '매도': 35,
    '강력 매도': 0
}
```

문제:
- 필터 없이 점수만으로 등급 결정
- 극단적 아웃라이어 미제외
- 시장 상황 미반영

### 4.2 개선안: 점수 + 필터 조합 (한국 방식 참고)

```python
# 개선된 등급 결정 로직
def determine_grade(final_score, momentum_score, filters_passed, sell_filters_passed):
    """
    final_score + 필터 조합으로 등급 결정

    매수 필터: Momentum(35-65), Trend, RS, EntryTiming
    매도 필터: Momentum(<30), Timing(<40), RS(<-20)
    """

    # 1. 강력 매수: 고점수 + 적정 모멘텀 + 필터 3개 이상
    if (final_score >= 80 and
        35 <= momentum_score <= 65 and
        filters_passed >= 3):
        return '강력 매수'

    # 2. 매수: 점수 >= 70 + 필터 3개 이상
    elif final_score >= 70 and filters_passed >= 3:
        return '매수'

    # 3. 매수 고려: 점수 >= 60 + 필터 2개 이상
    elif final_score >= 60 and filters_passed >= 2:
        return '매수 고려'

    # 4. 강력 매도: 점수 < 30 + 매도필터 3개
    elif final_score < 30 and sell_filters_passed >= 3:
        return '강력 매도'

    # 5. 매도: 점수 < 40 + 매도필터 2개 이상
    elif final_score < 40 and sell_filters_passed >= 2:
        return '매도'

    # 6. 매도 고려: 점수 < 50 또는 모멘텀 < 25
    elif final_score < 50 or momentum_score < 25:
        return '매도 고려'

    # 7. 중립: 나머지
    else:
        return '중립'
```

### 4.3 등급 구간 최적화 분석 스크립트

**필요성:** 최적 임계값을 데이터 기반으로 도출

```python
# us_grade_threshold_optimizer.py

async def analyze_optimal_thresholds(pool, start_date, end_date):
    """
    final_score 구간별 실제 성과 분석

    Returns:
        dict: {
            'score_ranges': [
                {'range': '80-100', 'count': N, 'avg_return': X%, 'hit_rate': Y%},
                ...
            ],
            'recommended_thresholds': {...}
        }
    """

    query = """
    WITH score_returns AS (
        SELECT
            g.final_score,
            g.final_grade,
            g.momentum_score,
            g.sector,
            b.market_cap,
            -- 90일 후 수익률
            (LEAD(d.close, 90) OVER (PARTITION BY g.symbol ORDER BY g.date) - d.close)
            / d.close * 100 as return_90d
        FROM us_stock_grade g
        JOIN us_daily d ON g.symbol = d.symbol AND g.date = d.date
        JOIN us_stock_basic b ON g.symbol = b.symbol
        WHERE g.date BETWEEN $1 AND $2
    )
    SELECT
        FLOOR(final_score / 5) * 5 as score_bin,
        COUNT(*) as count,
        AVG(return_90d) as avg_return,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY return_90d) as median_return,
        STDDEV(return_90d) as std_return,
        AVG(CASE WHEN return_90d > 0 THEN 1.0 ELSE 0.0 END) as hit_rate
    FROM score_returns
    WHERE return_90d IS NOT NULL
    GROUP BY FLOOR(final_score / 5) * 5
    ORDER BY score_bin
    """

    # 결과 분석 및 최적 임계값 도출
    # ...
```

### 4.4 Universe 필터링

극단적 아웃라이어 제외:

```python
UNIVERSE_EXCLUSION = {
    'market_cap_min': 100_000_000,  # $100M 이상
    'avg_volume_min': 1_000_000,     # 일평균 거래대금 $1M 이상
    'volatility_max': 150,           # 연간 변동성 150% 이하
    'ipo_days_min': 252,             # IPO 후 1년 이상
    'exclude_sectors': ['HEALTHCARE'],  # 바이오텍 매도 시그널 제외 (옵션)
}
```

---

## 5. Phase 4: 추가 리스크 지표

### 5.1 추가 컬럼

```sql
-- 변동성 사이징
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS inv_vol_weight DECIMAL(10,6);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS downside_vol DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS vol_percentile DECIMAL(5,2);

-- CVaR + Risk Budgeting
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS cvar_99 DECIMAL(6,2);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS corr_spy DECIMAL(5,3);
ALTER TABLE us_stock_grade ADD COLUMN IF NOT EXISTS tail_beta DECIMAL(5,3);
```

### 5.2 지표 명세

| 지표 | 컬럼명 | 계산식 | 용도 |
|------|--------|--------|------|
| 역변동성 가중치 | inv_vol_weight | 1 / volatility_annual | Risk Parity 가중치 |
| 하방 변동성 | downside_vol | std(음수 수익률만) * sqrt(252) | Sortino, 하방 리스크 |
| 변동성 백분위 | vol_percentile | 전체 종목 대비 변동성 순위 | 상대 비교 |
| CVaR 99% | cvar_99 | VaR 99% 이하 평균 손실 | 극단 리스크 |
| SPY 상관계수 | corr_spy | 60일 rolling correlation | 시장 분산 효과 |
| Tail Beta | tail_beta | 하락장에서의 Beta | 위기시 민감도 |

---

## 6. Phase 5: 과적합 방지

### 6.1 Walk-Forward Validation

```python
async def walk_forward_validation(
    pool,
    train_months: int = 9,
    test_months: int = 3,
    step_months: int = 1
):
    """
    Rolling Window Out-of-Sample 검증

    Args:
        train_months: 훈련 기간
        test_months: 테스트 기간
        step_months: 이동 단위

    Returns:
        dict: 기간별 성과 및 안정성 지표
    """
    # 예시 타임라인:
    # Train: 2024-01 ~ 2024-09
    # Test:  2024-10 ~ 2024-12
    # 다음:  2024-02 ~ 2024-10 (Train), 2024-11 ~ 2025-01 (Test)
    # ...
```

### 6.2 파라미터 최소화 원칙

| 파라미터 | 현재 | 권장 | 이유 |
|----------|------|------|------|
| 팩터 수 | 4개 | 4개 유지 | 충분 |
| 팩터 가중치 | 고정 | 고정 또는 1개 자유도 | 과적합 방지 |
| 등급 임계값 | 7개 | 5개로 축소 | 복잡도 감소 |
| 필터 조건 | 추가 | 최대 4개 | 해석 가능성 |

### 6.3 경제적 직관 검증

모든 팩터/필터는 경제적 논리가 있어야 함:

| 팩터 | 경제적 논리 | 미래 유효성 |
|------|------------|------------|
| Value | 과매도 → 적정가치 회귀 | 높음 |
| Quality | 좋은 기업 → 장기 생존 | 높음 |
| Growth | 성장 기업 → 시장 outperform | 중간 |
| Momentum | 정보 천천히 반영 (underreaction) | 낮음 (시장 효율화) |

---

## 7. 구현 일정 및 체크리스트

### Phase 1: VaR 개선 (3일)

- [ ] Hurst Exponent 계산 함수 구현 (us_main.py)
- [ ] 기간별 VaR 계산 함수 구현 (var_95_5d, var_95_20d, var_95_60d, var_95_90d)
- [ ] var_99, var_99_90d 계산 함수 구현
- [ ] DB 컬럼 추가 (ALTER TABLE)
- [ ] us_main.py에 신규 지표 연동
- [ ] 단위 테스트

### Phase 2: Momentum 중립화 (1일)

- [ ] momentum_ic 임계값 기준 중립화 로직 구현
- [ ] us_main.py에서 중립화 함수 호출 추가
- [ ] 로깅 추가 (중립화 적용 시 로그 출력)
- [ ] 백테스트로 효과 검증

### Phase 3: 등급 시스템 개선 (3일)

- [ ] us_grade_threshold_optimizer.py 스크립트 작성
- [ ] 현재 데이터로 최적 임계값 분석
- [ ] 필터 조합 로직 구현
- [ ] Universe 필터링 조건 적용
- [ ] 백테스트 및 검증

### Phase 4: 추가 리스크 지표 (2일)

- [ ] inv_vol_weight, downside_vol, vol_percentile 구현
- [ ] cvar_99, corr_spy, tail_beta 구현
- [ ] DB 컬럼 추가
- [ ] us_main.py 연동

### Phase 5: 검증 및 백테스트 (2일)

- [ ] us_model_analyzer 수정 (기간별 VaR 검증)
- [ ] VaR 초과율 재계산
- [ ] Grade Monotonicity 재계산
- [ ] Walk-forward validation 수행
- [ ] 결과 문서화

---

## 8. 예상 결과

### VaR 초과율 개선 예상

| 기간 | 현재 초과율 | 개선 후 예상 | 비고 |
|------|------------|-------------|------|
| 5일 | - | 6~8% | var_95_5d 신규 |
| 20일 | - | 6~8% | var_95_20d 신규 |
| 60일 | - | 6~8% | var_95_60d 신규 |
| 90일 | 41.53% | 6~8% | var_95_90d (Hurst 스케일링) |

### Grade 성과 개선 예상

| 지표 | 현재 | 개선 후 예상 |
|------|------|-------------|
| Monotonicity | -1.0 | +0.3 ~ +0.7 |
| 매도 Hit Rate | (역방향) | 45~55% |
| 강력매수 Hit Rate | - | 60~70% |
| IC (final_score) | 0.146 | 0.15~0.18 |

---

## 9. 위험 요소 및 대응

| 위험 | 발생 가능성 | 대응 |
|------|------------|------|
| Hurst 추정 불안정 | 중 | 데이터 부족 시 H=0.5 기본값 |
| 모멘텀 중립화 과도 | 낮 | IC 임계값 조절 (0.03 → 0.05) |
| 등급 임계값 과적합 | 중 | Walk-forward 검증 필수 |
| Universe 필터링 과도 | 낮 | 제외 조건 단계적 적용 |

---

## 10. 참고 자료

- 한국 시스템: `C:\project\alpha\quant\kr\analysis\지표 개선 방안.md`
- 현재 분석 결과: `C:\project\alpha\quant_analysis\us_result\20260117_리포트.md`
- VaR Deep Analysis: `C:\project\alpha\quant_analysis\us_result\20260117_var_deep_analysis.md`
- Extreme Outlier Analysis: `C:\project\alpha\quant_analysis\us_result\20260117_extreme_outlier_analysis.md`

---

**작성 완료**
