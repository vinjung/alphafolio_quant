# 시장 환경 변화 감지 및 퀀트 모델 업그레이드 방안 v2.0

**작성일**: 2025-12-08
**버전**: 2.0 (비판적 재검토 후 개선)
**참고 문헌**: 학술 연구 및 실무 사례 기반

---

## 1. 기존 방안(v1.0)의 비판적 검토

### 1.1 핵심 문제점 요약

| 문제 | v1.0 내용 | 비판 | 근거 |
|------|----------|------|------|
| **IC 임계값** | HEALTHY >= 0.15 | 과도하게 높음 | 학술 기준 IC >= 0.05면 유의미 |
| **IC 변동성** | 고려 안 함 | IC std가 mean의 3-11배 | arXiv:2010.08601 |
| **Look-ahead Bias** | Rolling IC 실시간 계산 | 미래 수익률 필요 | 실시간 불가능 |
| **Factor Timing** | IC 기반 동적 조정 | "Siren song" 문제 | arXiv:2410.14841v1 |
| **Regime Detection** | 단순 규칙 기반 | HMM 등 검증 방법론 부재 | MDPI JRFM 2020 |
| **Transaction Cost** | 무시 | 빈번한 조정 시 비용 발생 | 실무적 한계 |
| **Factor Crowding** | 언급만 | 정량화 방법 없음 | 측정 불가 |

### 1.2 학술 연구 기반 수정 사항

#### IC 변동성 문제 (arXiv:2010.08601)

> "The realized ICs are volatile. Of about the two-dozen models covered, the standard deviations of the realized ICs are at least three times as large as the means."

> "The time-varying component dominates the static component in driving the IC changes across time, accounting for about 95% of the total variability."

**시사점**: IC를 기반으로 한 동적 조정은 노이즈에 매우 민감하며, 단기 IC 변화에 반응하면 오히려 성과가 악화될 수 있음.

#### Factor Timing의 한계 (arXiv:2410.14841v1)

> "The challenge of accurately forecasting factor premia has been acknowledged by practitioners, with some referring to it as the 'siren song' of timing efforts."

**시사점**: Factor Timing은 매우 어렵고, 과도한 신뢰는 위험함. 정적 배분 또는 매우 보수적인 동적 조정이 더 나을 수 있음.

#### Regime-Switching 접근법 (MDPI JRFM 2020)

> "Results show the HMM model delivers higher returns and both higher Sharpe and Treynor ratios compared to other models."

**시사점**: 단순 규칙 기반보다 Hidden Markov Model (HMM)이 더 효과적.

---

## 2. Rolling IC 데이터 재분석

### 2.1 IC 변동성 분석

기존 데이터에서 IC 변동성 계산:

```
날짜별 IC_252d:
2024-01-16: 0.213
2024-03-06: 0.258
2024-05-08: 0.244
2024-07-10: 0.178
2024-09-19: 0.111
2024-11-21: 0.081

Mean IC: 0.181
Std IC:  0.069
CV (Std/Mean): 38%
```

**문제**: IC 변동계수 38%는 매우 높음. 이 정도 변동성에서 "IC 하락 감지"는 노이즈와 신호 구분이 어려움.

### 2.2 v1.0 임계값 재평가

| v1.0 임계값 | 학술 기준 | 수정 권고 |
|------------|----------|----------|
| HEALTHY >= 0.15 | IC >= 0.05 유의 | HEALTHY >= 0.08 |
| DEGRADED 0.08-0.15 | 0.03-0.05 경계 | DEGRADED 0.05-0.08 |
| CRITICAL 0.03-0.08 | 0.02-0.03 위험 | CRITICAL 0.02-0.05 |
| FAILED < 0.03 | < 0.02 무효 | FAILED < 0.02 |

### 2.3 Look-ahead Bias 문제

v1.0의 `get_rolling_ic()` 쿼리:
```sql
-- 문제: forward_return 계산에 미래 데이터 필요
(d_future.close - d.close) / d.close * 100 as forward_return
```

**실시간 모니터링 불가능**: IC 계산에는 미래 수익률이 필요하므로, "실시간 IC 모니터링"은 원칙적으로 불가능.

**해결책**:
1. Lagged IC 사용 (60일 전 IC로 현재 판단)
2. IC 대신 다른 지표 사용 (Signal Strength, Factor Spread)

---

## 3. 개선된 시장 환경 감지 시스템

### 3.1 학술 연구 기반 접근법

#### 접근법 1: Hidden Markov Model (HMM) Regime Detection

```python
"""
HMM 기반 Regime Detection

장점:
- 학술적으로 검증된 방법론
- 비지도 학습으로 레짐 자동 분류
- 연속적인 상태 전이 확률 제공

단점:
- 레짐 수(n_components) 사전 결정 필요
- 과적합 위험
- 실시간 예측의 지연

참고: MDPI JRFM 2020, QuantStart
"""

from hmmlearn.hmm import GaussianHMM
import numpy as np

class HMMRegimeDetector:
    """
    Hidden Markov Model 기반 시장 레짐 감지

    Features:
    - SPY 일간 수익률
    - 20일 실현 변동성
    - VIX 수준

    States (자동 분류):
    - Low Volatility (Bull)
    - High Volatility (Bear)
    - Transition (Neutral)
    """

    def __init__(self, n_regimes: int = 3):
        self.model = GaussianHMM(
            n_components=n_regimes,
            covariance_type="full",
            n_iter=1000,
            random_state=42
        )
        self.n_regimes = n_regimes
        self.is_fitted = False

    async def fit(self, db_manager, lookback_days: int = 504):
        """
        HMM 모델 학습 (2년 데이터)
        """
        query = """
        WITH daily_features AS (
            SELECT
                date,
                (close - LAG(close) OVER (ORDER BY date))
                    / LAG(close) OVER (ORDER BY date) as daily_return,
                STDDEV(close) OVER (
                    ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
                ) / AVG(close) OVER (
                    ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
                ) * SQRT(252) as realized_vol
            FROM us_daily_etf
            WHERE symbol = 'SPY'
            ORDER BY date DESC
            LIMIT $1
        )
        SELECT date, daily_return, realized_vol
        FROM daily_features
        WHERE daily_return IS NOT NULL
          AND realized_vol IS NOT NULL
        ORDER BY date
        """

        result = await db_manager.execute_query(query, lookback_days)

        if not result or len(result) < 100:
            raise ValueError("Insufficient data for HMM training")

        # Feature matrix 구성
        returns = np.array([float(r['daily_return']) for r in result])
        vols = np.array([float(r['realized_vol']) for r in result])

        features = np.column_stack([returns, vols])

        # HMM 학습
        self.model.fit(features)
        self.is_fitted = True

        # 레짐 특성 분석
        self._analyze_regimes(features)

        return self

    def _analyze_regimes(self, features):
        """
        각 레짐의 특성 분석 및 라벨링
        """
        states = self.model.predict(features)

        regime_stats = {}
        for i in range(self.n_regimes):
            mask = states == i
            regime_stats[i] = {
                'mean_return': features[mask, 0].mean(),
                'mean_vol': features[mask, 1].mean(),
                'count': mask.sum()
            }

        # 수익률 기준 정렬하여 라벨링
        sorted_regimes = sorted(
            regime_stats.items(),
            key=lambda x: x[1]['mean_return'],
            reverse=True
        )

        self.regime_labels = {
            sorted_regimes[0][0]: 'BULL',
            sorted_regimes[1][0]: 'NEUTRAL',
            sorted_regimes[2][0]: 'BEAR'
        }

        self.regime_stats = regime_stats

    async def predict_current_regime(self, db_manager) -> dict:
        """
        현재 레짐 예측
        """
        if not self.is_fitted:
            await self.fit(db_manager)

        # 최근 20일 데이터로 현재 상태 예측
        query = """
        WITH recent_features AS (
            SELECT
                date,
                (close - LAG(close) OVER (ORDER BY date))
                    / LAG(close) OVER (ORDER BY date) as daily_return,
                STDDEV(close) OVER (
                    ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
                ) / AVG(close) OVER (
                    ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
                ) * SQRT(252) as realized_vol
            FROM us_daily_etf
            WHERE symbol = 'SPY'
            ORDER BY date DESC
            LIMIT 21
        )
        SELECT date, daily_return, realized_vol
        FROM recent_features
        WHERE daily_return IS NOT NULL
        ORDER BY date
        """

        result = await db_manager.execute_query(query)

        returns = np.array([float(r['daily_return']) for r in result])
        vols = np.array([float(r['realized_vol']) for r in result])
        features = np.column_stack([returns, vols])

        # 현재 상태 예측
        current_state = self.model.predict(features)[-1]

        # 상태 전이 확률
        transition_probs = self.model.transmat_[current_state]

        return {
            'current_regime': self.regime_labels[current_state],
            'regime_id': int(current_state),
            'transition_probs': {
                self.regime_labels[i]: float(transition_probs[i])
                for i in range(self.n_regimes)
            },
            'regime_stats': self.regime_stats[current_state]
        }
```

#### 접근법 2: Lagged IC 기반 모니터링

```python
"""
Lagged IC 모니터링 (Look-ahead Bias 해결)

핵심 아이디어:
- 실시간 IC 계산 불가 (미래 수익률 필요)
- 대신 60일 전 시점의 IC를 현재 판단에 사용
- 60일 IC가 당시 이후 60일 수익률과의 상관관계

장점:
- Look-ahead Bias 없음
- 실제 구현 가능

단점:
- 60일 지연된 정보
- 급격한 변화에 늦은 반응
"""

class LaggedICMonitor:
    """
    지연된 IC 모니터링 시스템
    """

    # 학술 연구 기반 임계값 (수정됨)
    IC_THRESHOLDS = {
        'HEALTHY': 0.08,      # v1.0: 0.15 → 0.08 (학술 기준 완화)
        'DEGRADED': 0.05,     # v1.0: 0.08 → 0.05
        'CRITICAL': 0.02,     # v1.0: 0.03 → 0.02
        'FAILED': 0.00
    }

    # IC 변동성을 고려한 신뢰 구간
    IC_CONFIDENCE = {
        'high': 2.0,    # IC > mean + 2*std
        'normal': 0.0,  # mean - std < IC < mean + std
        'low': -2.0     # IC < mean - 2*std
    }

    async def get_lagged_ic(
        self,
        db_manager,
        lag_days: int = 60,
        lookback_window: int = 63
    ) -> dict:
        """
        지연된 IC 조회 (Look-ahead Bias 없음)

        Args:
            lag_days: IC 계산 완료까지 필요한 기간 (60일)
            lookback_window: IC 계산에 사용할 과거 데이터 기간

        Returns:
            lag_days 이전 시점의 IC (현재 시점에서 확정된 값)
        """
        query = """
        WITH lagged_scores AS (
            -- lag_days 이전 시점의 점수
            SELECT
                g.symbol,
                g.date as score_date,
                g.final_score,
                g.value_score,
                g.quality_score,
                g.momentum_score,
                g.growth_score
            FROM us_stock_grade g
            WHERE g.date <= CURRENT_DATE - $1 - $2
              AND g.date >= CURRENT_DATE - $1 - $2 - $3
              AND g.final_score IS NOT NULL
        ),
        returns AS (
            -- 해당 시점 이후 lag_days 동안의 수익률
            SELECT
                s.symbol,
                s.score_date,
                (d_end.close - d_start.close) / d_start.close * 100 as forward_return
            FROM lagged_scores s
            JOIN us_daily d_start
                ON s.symbol = d_start.symbol
                AND s.score_date = d_start.date
            JOIN us_daily d_end
                ON s.symbol = d_end.symbol
                AND d_end.date = (
                    SELECT MIN(date) FROM us_daily
                    WHERE symbol = s.symbol
                    AND date >= s.score_date + $1
                )
        )
        SELECT
            CORR(ls.final_score, r.forward_return) as total_ic,
            CORR(ls.value_score, r.forward_return) as value_ic,
            CORR(ls.quality_score, r.forward_return) as quality_ic,
            CORR(ls.momentum_score, r.forward_return) as momentum_ic,
            CORR(ls.growth_score, r.forward_return) as growth_ic,
            COUNT(*) as n_samples,
            STDDEV(ls.final_score) as score_std
        FROM lagged_scores ls
        JOIN returns r ON ls.symbol = r.symbol AND ls.score_date = r.score_date
        """

        result = await db_manager.execute_query(
            query, lag_days, 0, lookback_window
        )

        if not result or not result[0]['total_ic']:
            return self._default_response()

        row = result[0]
        total_ic = float(row['total_ic'])

        return {
            'total_ic': total_ic,
            'factor_ic': {
                'value': float(row['value_ic'] or 0),
                'quality': float(row['quality_ic'] or 0),
                'momentum': float(row['momentum_ic'] or 0),
                'growth': float(row['growth_ic'] or 0)
            },
            'status': self._classify_status(total_ic),
            'n_samples': row['n_samples'],
            'lag_days': lag_days,
            'note': f'IC calculated {lag_days} days ago (no look-ahead bias)'
        }

    def _classify_status(self, ic: float) -> str:
        """IC 상태 분류 (수정된 임계값)"""
        if ic >= self.IC_THRESHOLDS['HEALTHY']:
            return 'HEALTHY'
        elif ic >= self.IC_THRESHOLDS['DEGRADED']:
            return 'DEGRADED'
        elif ic >= self.IC_THRESHOLDS['CRITICAL']:
            return 'CRITICAL'
        else:
            return 'FAILED'
```

### 3.2 Factor Spread 기반 대안 지표

```python
"""
Factor Spread 모니터링

IC 대신 사용할 수 있는 실시간 지표:
- High Score 종목 vs Low Score 종목의 밸류에이션 갭
- Factor Crowding 프록시
- 실시간 계산 가능 (Look-ahead Bias 없음)

참고: Robeco 2024 White Paper
"""

class FactorSpreadMonitor:
    """
    Factor Spread 기반 실시간 모니터링
    """

    async def calculate_factor_spread(self, db_manager, analysis_date=None):
        """
        High Score vs Low Score 종목 간 스프레드 계산

        스프레드가 좁아지면 → Factor Crowding 신호
        스프레드가 넓어지면 → Factor 효과 유효
        """
        query = """
        WITH scored_stocks AS (
            SELECT
                symbol,
                final_score,
                NTILE(5) OVER (ORDER BY final_score) as quintile
            FROM us_stock_grade
            WHERE date = COALESCE($1::DATE, (
                SELECT MAX(date) FROM us_stock_grade
            ))
            AND final_score IS NOT NULL
        ),
        quintile_stats AS (
            SELECT
                quintile,
                AVG(final_score) as avg_score,
                COUNT(*) as count
            FROM scored_stocks
            GROUP BY quintile
        )
        SELECT
            (SELECT avg_score FROM quintile_stats WHERE quintile = 5) as top_quintile_avg,
            (SELECT avg_score FROM quintile_stats WHERE quintile = 1) as bottom_quintile_avg,
            (SELECT avg_score FROM quintile_stats WHERE quintile = 5) -
            (SELECT avg_score FROM quintile_stats WHERE quintile = 1) as score_spread
        """

        result = await db_manager.execute_query(query, analysis_date)

        if not result or not result[0]:
            return None

        row = result[0]
        spread = float(row['score_spread'] or 0)

        # 스프레드 해석
        # 정상: 상위 5분위 평균 - 하위 5분위 평균 = 30-40점
        # 압축: < 25점 → Factor Crowding 신호
        # 확대: > 45점 → Factor 분산 효과 강함

        if spread >= 40:
            spread_status = 'WIDE'
            factor_signal = 'STRONG'
        elif spread >= 30:
            spread_status = 'NORMAL'
            factor_signal = 'NORMAL'
        elif spread >= 25:
            spread_status = 'NARROW'
            factor_signal = 'WEAK'
        else:
            spread_status = 'COMPRESSED'
            factor_signal = 'CROWDING_ALERT'

        return {
            'top_quintile_avg': float(row['top_quintile_avg']),
            'bottom_quintile_avg': float(row['bottom_quintile_avg']),
            'score_spread': spread,
            'spread_status': spread_status,
            'factor_signal': factor_signal
        }
```

---

## 4. 개선된 모델 업그레이드 방안

### 4.1 보수적 접근법 권고

학술 연구 결과를 고려할 때, **과도한 동적 조정보다 보수적 접근**이 권장됨.

#### 권고 1: Factor Timing 최소화

> "We should generally assume that signals will decay over time and plan accordingly."

```python
# v1.0 방식 (과도한 동적 조정)
if ic < 0.08:
    weight *= 0.5  # 50% 감소

# v2.0 권고 (보수적 조정)
ADJUSTMENT_BOUNDS = {
    'max_increase': 0.10,   # 최대 10% 증가
    'max_decrease': 0.15,   # 최대 15% 감소
    'rebalance_frequency': 63  # 분기별 리밸런싱
}
```

#### 권고 2: Regime-based 정적 배분

HMM 레짐 감지 후, 레짐별 **고정 가중치** 사용:

```python
REGIME_STATIC_WEIGHTS = {
    'BULL': {
        'growth': 0.35,
        'momentum': 0.25,
        'quality': 0.20,
        'value': 0.20
    },
    'NEUTRAL': {
        'growth': 0.28,
        'quality': 0.27,
        'value': 0.25,
        'momentum': 0.20
    },
    'BEAR': {
        'quality': 0.40,
        'value': 0.30,
        'growth': 0.20,
        'momentum': 0.10
    }
}

# 레짐 전환 시에만 리밸런싱
# IC 변화에 따른 미세 조정 지양
```

#### 권고 3: Transaction Cost 고려

```python
TRANSACTION_COST_MODEL = {
    'commission': 0.001,      # 0.1%
    'slippage': 0.002,        # 0.2%
    'market_impact': 0.001,   # 0.1% (대형주 기준)
    'total_roundtrip': 0.008  # 0.8%
}

# 리밸런싱 결정 시 비용 고려
def should_rebalance(current_weights, target_weights, cost_model):
    expected_benefit = calculate_expected_ic_improvement()
    rebalance_cost = calculate_turnover(current_weights, target_weights) * cost_model['total_roundtrip']

    # 기대 효과가 비용의 2배 이상일 때만 리밸런싱
    return expected_benefit > rebalance_cost * 2
```

### 4.2 개선된 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: HMM Regime Detection (학술 검증 방법론)               │
│  - 3-State HMM (Bull/Neutral/Bear)                              │
│  - 입력: SPY 수익률, 실현변동성                                 │
│  - 출력: 현재 레짐 + 전이 확률                                  │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: Lagged IC Monitoring (Look-ahead Bias 없음)          │
│  - 60일 지연된 IC로 모델 유효성 모니터링                        │
│  - IC 변동성 고려 (신뢰구간 기반 판단)                          │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: Factor Spread Monitor (실시간 가능)                   │
│  - 점수 스프레드로 Factor Crowding 감지                         │
│  - 실시간 계산 가능                                             │
├─────────────────────────────────────────────────────────────────┤
│  Layer 4: Regime-based Static Weights (보수적 조정)             │
│  - 레짐별 고정 가중치 사용                                      │
│  - 레짐 전환 시에만 리밸런싱                                    │
│  - Transaction Cost 고려                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 v1.0 vs v2.0 비교

| 항목 | v1.0 | v2.0 |
|------|------|------|
| Regime Detection | 규칙 기반 (VIX, SPY 등) | HMM 기반 (학술 검증) |
| IC Monitoring | 실시간 (Look-ahead Bias) | Lagged IC (Bias 없음) |
| IC 임계값 | HEALTHY >= 0.15 | HEALTHY >= 0.08 |
| 가중치 조정 | 동적 (IC 기반) | 정적 (레짐 기반) |
| 조정 빈도 | 일별 가능 | 분기별 권고 |
| Transaction Cost | 미고려 | 고려 |
| Factor Crowding | 언급만 | Factor Spread 모니터링 |
| 복잡도 | 6-Layer | 4-Layer (단순화) |

---

## 5. 구현 우선순위 (수정)

### 5.1 Phase 1: HMM Regime Detection (2주)

```
1. hmmlearn 기반 HMM 구현
   - 3-State 모델 (Bull/Neutral/Bear)
   - SPY 2년 데이터로 학습
   - 일별 레짐 예측

2. 레짐별 정적 가중치 테이블
   - 백테스트로 최적 가중치 도출
   - Transaction Cost 포함 시뮬레이션
```

### 5.2 Phase 2: Lagged IC & Factor Spread (1주)

```
1. Lagged IC 쿼리 구현
   - 60일 지연 IC
   - 분기별 모니터링

2. Factor Spread 모니터링
   - 일별 스프레드 계산
   - Crowding Alert 시스템
```

### 5.3 Phase 3: 통합 및 백테스트 (2주)

```
1. us_main_v2.py 통합
   - HMM 레짐 → 가중치 결정
   - 분기별 리밸런싱 로직

2. 백테스트
   - 2022-2024 기간
   - v1.0 vs v2.0 성과 비교
```

---

## 6. 기대 효과 (수정)

### 6.1 정량적 기대 (보수적 추정)

| 항목 | v1.0 기대 | v2.0 기대 (보수적) | 근거 |
|------|----------|-------------------|------|
| IC 개선 | +22% (NASDAQ) | +5-10% | Factor Timing 한계 |
| Turnover | 높음 (일별 조정) | 낮음 (분기별) | Cost 절감 |
| Transaction Cost | 미고려 | 연 1-2% 절감 | 빈번한 조정 회피 |
| Regime 감지 정확도 | 규칙 기반 한계 | HMM 70%+ | 학술 연구 |

### 6.2 리스크 관리 개선

1. **Look-ahead Bias 제거**: Lagged IC로 편향 없는 모니터링
2. **과최적화 방지**: 단순화된 레짐 기반 접근
3. **Transaction Cost 최소화**: 분기별 리밸런싱

---

## 7. 결론

### 7.1 v1.0의 핵심 문제

1. **IC 변동성 과소평가**: IC std가 mean의 3-11배
2. **Look-ahead Bias**: 실시간 IC 계산 불가능
3. **Factor Timing 과신**: 학술 연구에서 "siren song" 경고
4. **복잡성 과다**: 6-Layer 시스템은 과도함

### 7.2 v2.0 핵심 개선

1. **HMM 기반 Regime Detection**: 학술적으로 검증된 방법론
2. **Lagged IC**: Look-ahead Bias 없는 모니터링
3. **보수적 동적 조정**: 레짐별 정적 가중치 + 분기별 리밸런싱
4. **단순화**: 4-Layer로 축소, Transaction Cost 고려

### 7.3 구현 권고

```
권고 1: Factor Timing에 과도한 기대를 하지 말 것
권고 2: HMM 등 검증된 Regime Detection 방법론 사용
권고 3: IC 변동성을 고려한 보수적 임계값 적용
권고 4: Transaction Cost를 명시적으로 고려
권고 5: 분기별 리밸런싱으로 Turnover 최소화
```

---

## References

1. [Dynamic Factor Allocation Leveraging Regime-Switching Signals](https://arxiv.org/html/2410.14841v1) - arXiv, October 2024
2. [Regime-Switching Factor Investing with Hidden Markov Models](https://www.mdpi.com/1911-8074/13/12/311) - MDPI JRFM, 2020
3. [Information Coefficient as a Performance Measure of Stock Selection Models](https://arxiv.org/pdf/2010.08601) - arXiv, 2020
4. [Market Regime Detection using Hidden Markov Models](https://www.quantstart.com/articles/market-regime-detection-using-hidden-markov-models-in-qstrader/) - QuantStart
5. [How to use the information coefficient to measure your alpha](https://www.pyquantnews.com/the-pyquant-newsletter/information-coefficient-measure-your-alpha) - PyQuant News
6. [Hidden Markov Models for Regime Detection in Diverse Financial Data](https://thepythonlab.medium.com/hidden-markov-models-for-regime-detection-in-diverse-financial-data-42cf19cd5d34) - The Python Lab, 2024

---

*Generated: 2025-12-08*
*Version: 2.0 (Critical Review)*
*File: us/analysis/시장환경_모델업그레이드_방안_v2.md*
