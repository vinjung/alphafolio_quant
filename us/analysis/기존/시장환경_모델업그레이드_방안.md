# 시장 환경 변화 감지 및 퀀트 모델 업그레이드 방안

**작성일**: 2025-12-08
**목적**: Rolling IC 하락 원인 분석 및 적응형 모델 설계

---

## 1. 현황 분석: Rolling IC 추이

### 1.1 시계열 데이터

| 날짜 | 종목 수 | IC_3d | IC_20d | IC_60d | IC_90d | IC_252d | 상태 |
|------|--------|-------|--------|--------|--------|---------|------|
| 2024-01-16 | 4,071 | 0.254 | 0.103 | 0.115 | 0.179 | **0.213** | 정상 |
| 2024-03-06 | 4,109 | 0.040 | 0.130 | 0.207 | 0.226 | **0.258** | 최고 |
| 2024-05-08 | 4,252 | 0.062 | 0.117 | 0.197 | 0.218 | **0.244** | 정상 |
| 2024-07-10 | 4,244 | -0.008 | 0.181 | 0.197 | 0.247 | **0.178** | 하락 시작 |
| 2024-09-19 | 4,298 | 0.105 | 0.122 | 0.202 | 0.174 | **0.111** | 급락 |
| 2024-11-21 | 4,357 | 0.006 | 0.018 | 0.042 | 0.125 | **0.081** | 저점 |
| 2025-03-13 | 4,465 | 0.082 | 0.229 | 0.138 | 0.032 | - | 불안정 |
| 2025-05-29 | 4,528 | 0.032 | 0.092 | 0.044 | **-0.041** | - | 위험 |
| 2025-07-16 | 4,599 | -0.006 | 0.158 | 0.005 | 0.131 | - | 회복 시작 |
| 2025-07-29 | 4,611 | 0.145 | 0.163 | 0.034 | 0.122 | - | 회복 |
| 2025-08-13 | 4,636 | -0.011 | 0.033 | 0.046 | - | - | 약화 |
| 2025-08-28 | 4,659 | 0.019 | -0.020 | 0.108 | - | - | 불안정 |
| 2025-09-09 | 4,715 | -0.020 | -0.088 | 0.116 | - | - | 단기 역전 |
| 2025-09-17 | 4,681 | -0.031 | -0.092 | - | - | - | 위험 |

### 1.2 핵심 관찰

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1 (2024-01 ~ 2024-05): 안정기                            │
│  - IC_252d: 0.21 ~ 0.26 (우수)                                  │
│  - 모델 예측력 검증됨                                            │
├─────────────────────────────────────────────────────────────────┤
│  Phase 2 (2024-07 ~ 2024-11): 급락기                            │
│  - IC_252d: 0.18 → 0.08 (60% 하락)                              │
│  - 시장 환경 급변                                                │
├─────────────────────────────────────────────────────────────────┤
│  Phase 3 (2025-03 ~ 2025-05): 위기기                            │
│  - IC_90d: 음수 전환 (-0.04)                                     │
│  - 모델 무력화                                                   │
├─────────────────────────────────────────────────────────────────┤
│  Phase 4 (2025-07 ~ 현재): 회복 시도                            │
│  - IC_90d: 0.12 ~ 0.13 (부분 회복)                              │
│  - 단기 IC 불안정                                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. IC 하락 원인 분석

### 2.1 가능한 원인들

| 원인 | 설명 | 검증 방법 |
|------|------|----------|
| **Factor Crowding** | 동일 Factor 전략 과밀화 → 알파 소멸 | Factor 보유 비중 분석 |
| **Regime Shift** | 시장 레짐 변화 (AI 버블, 금리 환경) | Regime별 IC 분석 |
| **Momentum Crash** | 급격한 추세 반전 | Momentum IC 별도 분석 |
| **Sector Rotation** | 섹터 주도주 변화 | 섹터별 IC 시계열 |
| **Volatility Spike** | 변동성 급등 시 Factor 효과 감소 | VIX vs IC 상관관계 |
| **Model Decay** | 모델 자체의 시간 경과 효과 감소 | 동일 모델 백테스트 |

### 2.2 Factor별 IC 변화 추정

```
2024 상반기 (정상):
- Growth IC:    0.18+ (최고)
- Value IC:     0.14+
- Quality IC:   0.10+
- Momentum IC:  0.08+

2024 하반기 (급락):
- Growth IC:    0.12 (유지)
- Value IC:     0.08 (하락)
- Quality IC:   0.06 (하락)
- Momentum IC:  0.02 (붕괴)  ← 주요 원인

추정 원인:
1. AI 주도 랠리에서 Momentum 역할 감소
2. 금리 환경 변화로 Value/Quality 효과 약화
3. 섹터 집중도 증가 (Mag7)로 Factor 분산 효과 감소
```

---

## 3. 시장 환경 변화 감지 방법

### 3.1 현재 시스템의 한계

```python
# 현재: us_market_regime.py
# 5-Regime + 5-Macro Environment + 4-Dimension Score

문제점:
1. Factor IC 변화를 직접 모니터링하지 않음
2. 과거 레짐 기반 가중치 (정적 조정)
3. 시장 환경 변화에 대한 지연 반응
4. Factor Crowding/Decay 감지 불가
```

### 3.2 제안: 6-Layer 시장 환경 감지 시스템

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: Real-time IC Monitoring (신규)                        │
│  - Rolling IC 21일/63일/126일 계산                               │
│  - IC 변화율 모니터링 (Δ IC)                                     │
│  - Factor별 IC 분해 분석                                         │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: Regime Detection (기존 강화)                          │
│  - 5-Regime: AI_BULL, TIGHTENING, RECOVERY, CRISIS, NEUTRAL     │
│  - Regime별 Factor IC 매핑 추가                                  │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: Macro Environment (기존)                              │
│  - 5-Macro: SOFT_LANDING, HARD_LANDING, REFLATION, etc.         │
├─────────────────────────────────────────────────────────────────┤
│  Layer 4: 4-Dimension Composite Score (기존)                    │
│  - Liquidity, Macro, Volatility, Risk Appetite                  │
├─────────────────────────────────────────────────────────────────┤
│  Layer 5: Factor Effectiveness Score (신규)                     │
│  - 각 Factor의 현재 유효성 점수 (0-100)                          │
│  - IC 기반 동적 업데이트                                         │
├─────────────────────────────────────────────────────────────────┤
│  Layer 6: Adaptive Weight Engine (신규)                         │
│  - Layer 1-5 종합하여 실시간 가중치 조정                         │
│  - Factor Decay 감지 시 자동 축소                                │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 Layer 1: Real-time IC Monitoring 설계

```python
class RealTimeICMonitor:
    """
    실시간 IC 모니터링 시스템

    주요 기능:
    1. Rolling IC 계산 (21d, 63d, 126d)
    2. IC 변화율 감지 (Δ IC)
    3. Factor별 IC 분해
    4. 이상 감지 알림
    """

    # IC 임계값
    IC_THRESHOLDS = {
        'HEALTHY': 0.15,      # IC >= 0.15: 정상
        'DEGRADED': 0.08,     # 0.08 <= IC < 0.15: 약화
        'CRITICAL': 0.03,     # 0.03 <= IC < 0.08: 위험
        'FAILED': 0.00        # IC < 0.03: 실패
    }

    # IC 변화율 임계값
    DELTA_THRESHOLDS = {
        'RAPID_DECLINE': -0.05,   # 21일간 5%p 이상 하락
        'MODERATE_DECLINE': -0.03,
        'STABLE': 0.02,
        'IMPROVING': 0.03
    }

    async def calculate_rolling_ic(self, lookback_days: int = 63) -> Dict:
        """
        Rolling IC 계산

        Returns:
            {
                'total_ic': float,
                'factor_ic': {
                    'growth': float,
                    'value': float,
                    'quality': float,
                    'momentum': float
                },
                'ic_status': str,  # HEALTHY/DEGRADED/CRITICAL/FAILED
                'delta_ic_21d': float,
                'delta_status': str
            }
        """
        pass

    async def detect_ic_anomaly(self) -> Dict:
        """
        IC 이상 감지

        감지 항목:
        1. 급격한 IC 하락 (21일 기준)
        2. Factor간 IC 불균형 심화
        3. 특정 Factor IC 음수 전환
        4. 장기 추세 대비 단기 이탈
        """
        pass
```

### 3.4 Layer 5: Factor Effectiveness Score 설계

```python
class FactorEffectivenessScore:
    """
    Factor 유효성 점수 (0-100)

    각 Factor의 현재 예측력을 점수화
    """

    def calculate_effectiveness(self, factor: str) -> Dict:
        """
        Factor 유효성 계산

        Components:
        1. IC Score (40%): 현재 IC 수준
        2. IC Stability (20%): IC 변동성 (낮을수록 좋음)
        3. IC Trend (20%): IC 추세 (상승 시 가산)
        4. Sector Coverage (10%): 섹터별 IC 일관성
        5. Regime Consistency (10%): 레짐별 IC 일관성

        Returns:
            {
                'effectiveness_score': float (0-100),
                'components': {
                    'ic_score': float,
                    'ic_stability': float,
                    'ic_trend': float,
                    'sector_coverage': float,
                    'regime_consistency': float
                },
                'recommendation': str  # 'USE', 'REDUCE', 'EXCLUDE'
            }
        """
        pass

    # Factor 사용 권고
    RECOMMENDATIONS = {
        'USE': effectiveness >= 60,      # 정상 사용
        'REDUCE': 40 <= effectiveness < 60,  # 가중치 축소
        'EXCLUDE': effectiveness < 40    # 제외 권고
    }
```

---

## 4. 모델 업그레이드 방안

### 4.1 Phase 4.0: Adaptive Factor Weighting

```python
class AdaptiveFactorWeighting:
    """
    적응형 Factor 가중치 시스템

    현재 방식:
    - Regime → Static Weights (고정 비율)

    개선 방식:
    - Regime × Factor Effectiveness → Dynamic Weights
    """

    def calculate_adaptive_weights(
        self,
        regime: str,
        factor_effectiveness: Dict[str, float],
        exchange: str = None
    ) -> Dict[str, float]:
        """
        적응형 가중치 계산

        Algorithm:
        1. Base weights from regime
        2. Adjust by factor effectiveness score
        3. Apply exchange-specific modifier
        4. Normalize to sum=1.0

        Example:
        - Regime: AI_BULL → Momentum 35%
        - Momentum Effectiveness: 40 (REDUCE)
        - Adjusted: Momentum 35% × 0.7 = 24.5%
        - Redistribute to Growth/Quality
        """

        # 1. Base weights
        base = REGIME_WEIGHTS[regime].copy()

        # 2. Effectiveness adjustment
        for factor, effectiveness in factor_effectiveness.items():
            if effectiveness >= 60:
                multiplier = 1.0
            elif effectiveness >= 40:
                multiplier = 0.7 + (effectiveness - 40) / 20 * 0.3
            else:
                multiplier = 0.3 + effectiveness / 40 * 0.4

            base[factor] *= multiplier

        # 3. Exchange modifier (NASDAQ: Momentum 추가 감소)
        if exchange == 'NASDAQ':
            base['momentum'] *= 0.5
            base['growth'] *= 1.2

        # 4. Normalize
        total = sum(base.values())
        return {k: v / total for k, v in base.items()}
```

### 4.2 Phase 4.1: IC-based Model Selection

```python
class ICBasedModelSelector:
    """
    IC 수준에 따른 모델 선택

    IC 상태별 전략:
    - HEALTHY (IC >= 0.15): Full Factor Model 사용
    - DEGRADED (0.08-0.15): Reduced Factor Model (상위 2개 Factor만)
    - CRITICAL (0.03-0.08): Momentum-only 또는 Equal Weight
    - FAILED (IC < 0.03): Market Index 추종 (Factor 포기)
    """

    MODEL_STRATEGIES = {
        'FULL_FACTOR': {
            'description': '4-Factor 전체 사용',
            'condition': 'IC >= 0.15',
            'weights': 'adaptive'
        },
        'REDUCED_FACTOR': {
            'description': '상위 2개 Factor만 사용',
            'condition': '0.08 <= IC < 0.15',
            'weights': {'growth': 0.55, 'value': 0.45}  # IC 순위 기반
        },
        'CONSERVATIVE': {
            'description': 'Equal Weight + Quality 필터',
            'condition': '0.03 <= IC < 0.08',
            'weights': 'equal',
            'filter': 'quality_score >= 60'
        },
        'PASSIVE': {
            'description': 'Factor 포기, Index 추종',
            'condition': 'IC < 0.03',
            'action': 'skip_factor_model'
        }
    }
```

### 4.3 Phase 4.2: Factor Rotation System

```python
class FactorRotationSystem:
    """
    Factor 로테이션 시스템

    특정 Factor IC가 급락하면 다른 Factor로 대체
    """

    ROTATION_RULES = {
        'MOMENTUM_CRASH': {
            'trigger': 'momentum_ic < 0.02',
            'action': 'redistribute_to_growth_quality',
            'new_weights': {
                'growth': '+0.15',
                'quality': '+0.10',
                'value': '+0.05',
                'momentum': '-0.30'
            }
        },
        'VALUE_TRAP': {
            'trigger': 'value_ic < 0.05 AND value_ic_trend < -0.03',
            'action': 'reduce_value_increase_quality',
            'new_weights': {
                'value': '-0.15',
                'quality': '+0.10',
                'growth': '+0.05'
            }
        },
        'QUALITY_PREMIUM_FADE': {
            'trigger': 'quality_ic < 0.03',
            'action': 'shift_to_momentum_growth',
            'new_weights': {
                'quality': '-0.10',
                'growth': '+0.05',
                'momentum': '+0.05'
            }
        }
    }

    async def check_rotation_triggers(self, factor_ic: Dict) -> Optional[str]:
        """로테이션 트리거 확인"""
        pass

    async def execute_rotation(self, rule_name: str, current_weights: Dict) -> Dict:
        """로테이션 실행"""
        pass
```

### 4.4 Phase 4.3: Regime-IC Mapping Table

```python
# 각 레짐에서 예상되는 Factor IC (경험적 데이터 기반)
REGIME_IC_EXPECTATIONS = {
    'AI_BULL': {
        'expected_ic': {
            'growth': 0.20,
            'momentum': 0.15,
            'quality': 0.08,
            'value': 0.05
        },
        'ic_stability': 'medium',
        'optimal_weights': {'growth': 0.40, 'momentum': 0.30, 'quality': 0.20, 'value': 0.10}
    },
    'TIGHTENING': {
        'expected_ic': {
            'quality': 0.15,
            'value': 0.12,
            'growth': 0.08,
            'momentum': 0.03  # Momentum 효과 약함
        },
        'ic_stability': 'low',  # IC 변동성 높음
        'optimal_weights': {'quality': 0.35, 'value': 0.35, 'growth': 0.20, 'momentum': 0.10}
    },
    'RECOVERY': {
        'expected_ic': {
            'momentum': 0.18,
            'value': 0.15,
            'growth': 0.12,
            'quality': 0.08
        },
        'ic_stability': 'high',
        'optimal_weights': {'momentum': 0.30, 'value': 0.30, 'growth': 0.25, 'quality': 0.15}
    },
    'CRISIS': {
        'expected_ic': {
            'quality': 0.20,
            'value': 0.10,
            'growth': 0.05,
            'momentum': -0.05  # Momentum 역효과
        },
        'ic_stability': 'very_low',
        'optimal_weights': {'quality': 0.50, 'value': 0.30, 'growth': 0.15, 'momentum': 0.05}
    },
    'NEUTRAL': {
        'expected_ic': {
            'growth': 0.12,
            'value': 0.10,
            'quality': 0.08,
            'momentum': 0.06
        },
        'ic_stability': 'medium',
        'optimal_weights': {'growth': 0.28, 'value': 0.27, 'quality': 0.25, 'momentum': 0.20}
    }
}
```

---

## 5. 구현 우선순위

### 5.1 Phase 4.0 (즉시 구현)

```
1. IC Monitoring 대시보드
   - Rolling IC 21d/63d 자동 계산
   - IC 상태 알림 시스템
   - Factor별 IC 분해

2. Adaptive Weight 기본 로직
   - Factor Effectiveness Score 계산
   - 가중치 자동 조정 (±20% 범위)

예상 효과:
- IC 하락 시 조기 감지
- Factor 효과 약화 시 자동 축소
```

### 5.2 Phase 4.1 (1-2주 내)

```
1. IC-based Model Selection
   - IC 상태별 모델 분기
   - CRITICAL 상태 시 보수적 전략

2. NASDAQ Momentum 완전 분리
   - NASDAQ: Growth 중심 모델
   - NYSE: Balanced 모델

예상 효과:
- NASDAQ IC 개선 (+0.05)
- 전체 IC 안정성 향상
```

### 5.3 Phase 4.2 (2-4주 내)

```
1. Factor Rotation System
   - 자동 로테이션 규칙
   - 트리거 기반 가중치 변경

2. Regime-IC Mapping 검증
   - 과거 데이터로 매핑 테이블 최적화
   - 레짐별 최적 가중치 도출

예상 효과:
- Factor Crash 시 손실 제한
- 레짐 전환 시 빠른 대응
```

### 5.4 Phase 4.3 (1-2개월)

```
1. ML-based IC Prediction
   - IC 하락 예측 모델
   - Feature: VIX, 거래량, 섹터 집중도 등

2. Dynamic Rebalancing Engine
   - 일별 가중치 미세 조정
   - Transaction Cost 고려

예상 효과:
- IC 하락 사전 예측
- 최적 타이밍 리밸런싱
```

---

## 6. 구현 코드 스케치

### 6.1 us_ic_monitor.py (신규 파일)

```python
"""
US IC Monitoring System
Phase 4.0

File: us/us_ic_monitor.py
"""

import logging
from typing import Dict, List, Optional
from datetime import date, timedelta
from enum import Enum

logger = logging.getLogger(__name__)


class ICStatus(Enum):
    HEALTHY = "HEALTHY"       # IC >= 0.15
    DEGRADED = "DEGRADED"     # 0.08 <= IC < 0.15
    CRITICAL = "CRITICAL"     # 0.03 <= IC < 0.08
    FAILED = "FAILED"         # IC < 0.03


class ICMonitor:
    """
    Real-time IC Monitoring System
    """

    IC_THRESHOLDS = {
        ICStatus.HEALTHY: 0.15,
        ICStatus.DEGRADED: 0.08,
        ICStatus.CRITICAL: 0.03,
        ICStatus.FAILED: 0.00
    }

    def __init__(self, db_manager):
        self.db = db_manager

    async def get_rolling_ic(
        self,
        lookback_days: int = 63,
        forward_days: int = 60,
        analysis_date: date = None
    ) -> Dict:
        """
        Rolling IC 계산

        Args:
            lookback_days: IC 계산 기간 (과거 데이터)
            forward_days: 수익률 계산 기간
            analysis_date: 분석 기준일

        Returns:
            {
                'total_ic': float,
                'factor_ic': Dict[str, float],
                'status': ICStatus,
                'delta_21d': float,
                'recommendations': Dict
            }
        """
        analysis_date = analysis_date or date.today()

        query = """
        WITH score_returns AS (
            SELECT
                g.symbol,
                g.date,
                g.final_score,
                g.value_score,
                g.quality_score,
                g.momentum_score,
                g.growth_score,
                (d_future.close - d.close) / d.close * 100 as forward_return
            FROM us_stock_grade g
            JOIN us_daily d ON g.symbol = d.symbol AND g.date = d.date
            JOIN us_daily d_future
                ON g.symbol = d_future.symbol
                AND d_future.date = (
                    SELECT MIN(date) FROM us_daily
                    WHERE symbol = g.symbol
                    AND date >= g.date + $3
                )
            WHERE g.date >= $1 - $2
              AND g.date <= $1
              AND g.final_score IS NOT NULL
        )
        SELECT
            CORR(final_score, forward_return) as total_ic,
            CORR(value_score, forward_return) as value_ic,
            CORR(quality_score, forward_return) as quality_ic,
            CORR(momentum_score, forward_return) as momentum_ic,
            CORR(growth_score, forward_return) as growth_ic,
            COUNT(*) as n_samples
        FROM score_returns
        """

        result = await self.db.execute_query(
            query,
            analysis_date,
            lookback_days,
            forward_days
        )

        if not result or not result[0]:
            return self._default_response()

        row = result[0]
        total_ic = float(row['total_ic'] or 0)

        factor_ic = {
            'value': float(row['value_ic'] or 0),
            'quality': float(row['quality_ic'] or 0),
            'momentum': float(row['momentum_ic'] or 0),
            'growth': float(row['growth_ic'] or 0)
        }

        # IC 상태 판정
        status = self._classify_status(total_ic)

        # 21일 전 IC 조회하여 변화량 계산
        delta_21d = await self._get_ic_delta(analysis_date, 21, forward_days)

        # 권고사항 생성
        recommendations = self._generate_recommendations(
            total_ic, factor_ic, status, delta_21d
        )

        return {
            'total_ic': total_ic,
            'factor_ic': factor_ic,
            'status': status,
            'delta_21d': delta_21d,
            'n_samples': row['n_samples'],
            'recommendations': recommendations
        }

    def _classify_status(self, ic: float) -> ICStatus:
        """IC 상태 분류"""
        if ic >= self.IC_THRESHOLDS[ICStatus.HEALTHY]:
            return ICStatus.HEALTHY
        elif ic >= self.IC_THRESHOLDS[ICStatus.DEGRADED]:
            return ICStatus.DEGRADED
        elif ic >= self.IC_THRESHOLDS[ICStatus.CRITICAL]:
            return ICStatus.CRITICAL
        else:
            return ICStatus.FAILED

    async def _get_ic_delta(
        self,
        analysis_date: date,
        delta_days: int,
        forward_days: int
    ) -> float:
        """IC 변화량 계산"""
        past_date = analysis_date - timedelta(days=delta_days)
        past_ic = await self.get_rolling_ic(63, forward_days, past_date)
        current_ic = await self.get_rolling_ic(63, forward_days, analysis_date)

        return current_ic['total_ic'] - past_ic['total_ic']

    def _generate_recommendations(
        self,
        total_ic: float,
        factor_ic: Dict[str, float],
        status: ICStatus,
        delta_21d: float
    ) -> Dict:
        """권고사항 생성"""

        recommendations = {
            'model_strategy': 'FULL_FACTOR',
            'weight_adjustments': {},
            'alerts': []
        }

        # 1. 모델 전략 결정
        if status == ICStatus.FAILED:
            recommendations['model_strategy'] = 'PASSIVE'
            recommendations['alerts'].append(
                'CRITICAL: IC < 0.03, Factor model ineffective'
            )
        elif status == ICStatus.CRITICAL:
            recommendations['model_strategy'] = 'CONSERVATIVE'
            recommendations['alerts'].append(
                'WARNING: IC < 0.08, Use conservative strategy'
            )
        elif status == ICStatus.DEGRADED:
            recommendations['model_strategy'] = 'REDUCED_FACTOR'
            recommendations['alerts'].append(
                'CAUTION: IC degraded, Reduce factor exposure'
            )

        # 2. Factor별 가중치 조정
        for factor, ic in factor_ic.items():
            if ic < 0.03:
                recommendations['weight_adjustments'][factor] = 'REDUCE_50%'
            elif ic < 0.08:
                recommendations['weight_adjustments'][factor] = 'REDUCE_25%'
            elif ic > 0.15:
                recommendations['weight_adjustments'][factor] = 'INCREASE_10%'

        # 3. IC 하락 경고
        if delta_21d < -0.05:
            recommendations['alerts'].append(
                f'ALERT: Rapid IC decline ({delta_21d:.1%} in 21d)'
            )

        return recommendations

    def _default_response(self) -> Dict:
        """기본 응답 (데이터 없을 때)"""
        return {
            'total_ic': 0.0,
            'factor_ic': {
                'value': 0.0,
                'quality': 0.0,
                'momentum': 0.0,
                'growth': 0.0
            },
            'status': ICStatus.FAILED,
            'delta_21d': 0.0,
            'recommendations': {
                'model_strategy': 'PASSIVE',
                'weight_adjustments': {},
                'alerts': ['No IC data available']
            }
        }


class AdaptiveWeightEngine:
    """
    적응형 가중치 엔진
    """

    def __init__(self, ic_monitor: ICMonitor):
        self.ic_monitor = ic_monitor

    async def get_adaptive_weights(
        self,
        regime: str,
        exchange: str = None,
        analysis_date: date = None
    ) -> Dict[str, float]:
        """
        적응형 가중치 계산

        Returns:
            {'value': float, 'quality': float, 'momentum': float, 'growth': float}
        """
        # 1. IC 상태 조회
        ic_data = await self.ic_monitor.get_rolling_ic(
            lookback_days=63,
            forward_days=60,
            analysis_date=analysis_date
        )

        # 2. 기본 가중치 (레짐 기반)
        from us_market_regime import REGIME_WEIGHTS
        base_weights = REGIME_WEIGHTS.get(regime, REGIME_WEIGHTS['NEUTRAL']).copy()
        del base_weights['description']

        # 3. Factor Effectiveness 조정
        for factor, ic in ic_data['factor_ic'].items():
            effectiveness = self._ic_to_effectiveness(ic)
            multiplier = self._effectiveness_to_multiplier(effectiveness)
            base_weights[factor] *= multiplier

        # 4. 거래소 조정
        if exchange == 'NASDAQ':
            base_weights['momentum'] *= 0.5
            base_weights['growth'] *= 1.2

        # 5. 정규화
        total = sum(base_weights.values())
        if total > 0:
            base_weights = {k: v / total for k, v in base_weights.items()}

        return base_weights

    def _ic_to_effectiveness(self, ic: float) -> float:
        """IC → Effectiveness Score (0-100)"""
        if ic >= 0.20:
            return 100
        elif ic >= 0.15:
            return 80 + (ic - 0.15) / 0.05 * 20
        elif ic >= 0.10:
            return 60 + (ic - 0.10) / 0.05 * 20
        elif ic >= 0.05:
            return 40 + (ic - 0.05) / 0.05 * 20
        elif ic >= 0.00:
            return 20 + ic / 0.05 * 20
        else:
            return max(0, 20 + ic * 100)  # 음수 IC 페널티

    def _effectiveness_to_multiplier(self, effectiveness: float) -> float:
        """Effectiveness → Weight Multiplier"""
        if effectiveness >= 80:
            return 1.1  # 10% 증가
        elif effectiveness >= 60:
            return 1.0  # 유지
        elif effectiveness >= 40:
            return 0.8  # 20% 감소
        elif effectiveness >= 20:
            return 0.5  # 50% 감소
        else:
            return 0.3  # 70% 감소
```

---

## 7. 기대 효과

### 7.1 정량적 기대 효과

| 항목 | 현재 | Phase 4.0 후 | 개선 |
|------|------|-------------|------|
| IC 급락 감지 | 수동 | 자동 (21일 내) | - |
| NASDAQ IC | 0.131 | 0.16+ | +22% |
| 전체 IC | 0.178 | 0.20+ | +12% |
| IC 안정성 (σ) | 0.08 | 0.05 | -37% |
| Factor Crash 손실 | 전액 노출 | 50% 축소 | -50% |

### 7.2 정성적 기대 효과

1. **조기 경보 시스템**: IC 하락 시 자동 알림
2. **적응형 대응**: 시장 환경에 따른 자동 가중치 조정
3. **리스크 관리**: Factor 무력화 시 보수적 전략 전환
4. **투명성**: IC 상태 대시보드로 모델 신뢰도 가시화

---

## 8. 결론

### 8.1 핵심 문제

```
2024년 하반기 이후 IC 하락:
- 원인: Momentum Factor 붕괴 + 시장 집중도 증가
- 현재 시스템: IC 변화 감지 부재
- 결과: 모델 예측력 60% 하락
```

### 8.2 해결 방안

```
1. IC Monitoring System (Layer 1)
   → 실시간 IC 모니터링 및 알림

2. Factor Effectiveness Score (Layer 5)
   → Factor별 유효성 점수화

3. Adaptive Weight Engine (Layer 6)
   → IC 기반 동적 가중치 조정

4. IC-based Model Selection
   → IC 상태별 모델 전략 분기
```

### 8.3 다음 단계

1. `us_ic_monitor.py` 구현
2. 기존 `us_main_v2.py`에 IC Monitor 통합
3. IC Monitoring 대시보드 구축
4. 백테스트로 효과 검증

---

*Generated: 2025-12-08*
*File: us/analysis/시장환경_모델업그레이드_방안.md*
