# Phase 3.7 - Value Strategy Improvement Plan
## í•œêµ­ ì‹œì¥ ë§ì¶¤í˜• ë°¸ë¥˜ ì „ëµ ê°œì„  ì‘ì—…ê³„íšì„œ

**ì‘ì„±ì¼**: 2025-11-22
**ëª©í‘œ**: IC ìµœì í™”ê°€ ì•„ë‹Œ, í•œêµ­ ì‹œì¥ì˜ ë³¸ì§ˆì„ ë°˜ì˜í•œ í€€íŠ¸ ì „ëµ êµ¬ì¶•
**í˜„ì¬ ë¬¸ì œ**: Value IC -0.031 (ì—­íš¨ê³¼)
**ê°œì„  ëª©í‘œ**: Value IC +0.02~0.05 (ë…¼ë¦¬ì  íƒ€ë‹¹ì„± ê¸°ë°˜)

---

## ğŸ“‹ ëª©ì°¨

1. [ì‘ì—… ê°œìš”](#ì‘ì—…-ê°œìš”)
2. [Phase 1: ì¦‰ì‹œ ì ìš© (1-2ì£¼)](#phase-1-ì¦‰ì‹œ-ì ìš©)
3. [Phase 2: ì¤‘ê¸° ê°œì„  (2-4ì£¼)](#phase-2-ì¤‘ê¸°-ê°œì„ )
4. [Phase 3: ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸](#phase-3-ê°€ì¤‘ì¹˜-ì—…ë°ì´íŠ¸)
5. [Phase 4: í…ŒìŠ¤íŠ¸ ë° ê²€ì¦](#phase-4-í…ŒìŠ¤íŠ¸-ë°-ê²€ì¦)
6. [íŒŒì¼ë³„ ìˆ˜ì • ì²´í¬ë¦¬ìŠ¤íŠ¸](#íŒŒì¼ë³„-ìˆ˜ì •-ì²´í¬ë¦¬ìŠ¤íŠ¸)
7. [ì½”ë“œ êµ¬í˜„ ìƒì„¸](#ì½”ë“œ-êµ¬í˜„-ìƒì„¸)
8. [ê²€ì¦ ê¸°ì¤€](#ê²€ì¦-ê¸°ì¤€)

---

## ì‘ì—… ê°œìš”

### í•µì‹¬ ì›ì¹™

1. **IC ìµœì í™”ê°€ ëª©í‘œê°€ ì•„ë‹ˆë‹¤** - ì „ëµì˜ ë…¼ë¦¬ì  íƒ€ë‹¹ì„±ì´ ìš°ì„ 
2. **í•œêµ­ ì‹œì¥ íŠ¹ì„± ë°˜ì˜** - Growth > Value, ì ì ì„±ì¥ì£¼ ê³ ìˆ˜ìµ
3. **ì„¹í„° ë§¹ì‹  ê¸ˆì§€** - ë§í•œ ì„¹í„°ì—ì„œ 1ë“±í•´ë„ ì˜ë¯¸ ì—†ìŒ
4. **ê³¼ì í•© ë°©ì§€** - ì‹œì¥ ì›ë¦¬ ê¸°ë°˜ ì„¤ê³„

### ì£¼ìš” ê°œì„  ì‚¬í•­

| í•­ëª© | í˜„ì¬ ë¬¸ì œ | ê°œì„  ë°©ì•ˆ | ì˜ˆìƒ íš¨ê³¼ |
|------|----------|----------|----------|
| ì ì ì„±ì¥ì£¼ | 0ì  â†’ ê¸°íšŒ ì†ì‹¤ | V17 ì¶”ê°€ (PSR+Growth) | +141% ìˆ˜ìµ í¬ì°© |
| ë°°ë‹¹ í•¨ì • | 100ì  â†’ Value Trap | V4 ì¬ì„¤ê³„ (ì§€ì†ê°€ëŠ¥ì„±) | -12% ì†ì‹¤ íšŒí”¼ |
| ë§í•œ ì„¹í„° | ì„¹í„° ë‚´ 1ë“± 90ì  | Sector Health Check | ì ˆëŒ€ í‰ê°€ë¡œ ì „í™˜ |
| EV/Sales | ì„±ì¥ë¥  ë¯¸ë°˜ì˜ | V18 ì¶”ê°€ (Growth ì¡°ì •) | ê³ ì„±ì¥ì£¼ ì¸ì‹ |
| Quality+Value | ë‹¨ìˆœ ê²°í•© | V20 (ROIC-Based) | ì§„ì§œ Quality í¬ì°© |

---

## Phase 1: ì¦‰ì‹œ ì ìš© (1-2ì£¼)

### Task 1.1: V17 - ì ì ì„±ì¥ ê¸°ì—… ì „ëµ ì¶”ê°€

**ëª©í‘œ**: ì ì ê¸°ì—…ì„ 0ì  ì²˜ë¦¬í•˜ì§€ ì•Šê³  ì„±ì¥ì„±ìœ¼ë¡œ í‰ê°€

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

#### Step 1: V17 í•¨ìˆ˜ ì¶”ê°€

**ìœ„ì¹˜**: `kr\kr_value_factor.py` í•˜ë‹¨ (ê¸°ì¡´ V16 ë‹¤ìŒ)

```python
# ========================================================================
# V17. Growth-Adjusted Value for Loss-Making Companies (ì‹ ê·œ)
# ========================================================================

async def calculate_v17_growth_adjusted_value(self):
    """
    V17. Growth-Adjusted Value Strategy (ì ì ì„±ì¥ ê¸°ì—…ìš©)

    Description: ì ì ê¸°ì—…ì„ ì„±ì¥ì„±ê³¼ PSRë¡œ í‰ê°€

    Logic:
    - ë§¤ì¶œ ì„±ì¥ë¥  (3ë…„ CAGR, 1ë…„ ì„±ì¥ë¥ )
    - ì˜ì—… ë§ˆì§„ ê°œì„  ì¶”ì„¸
    - í˜„ê¸ˆ ì†Œì§„ìœ¨ (ìƒì¡´ ê°€ëŠ¥ì„±)
    - PSR (ì„¹í„° ëŒ€ë¹„)

    Scoring:
    - High Growth (CAGR >50%, 1Y >30%, ë§ˆì§„ ê°œì„ , ìƒì¡´ >12ê°œì›”): 85ì 
    - Mid Growth (CAGR >20%, 1Y >10%, ë§ˆì§„ ìœ ì§€, ìƒì¡´ >6ê°œì›”): 65ì 
    - Low Growth / Troubled: 0-10ì 
    """

    # Step 1: ì ì ì—¬ë¶€ í™•ì¸
    net_income_query = """
    SELECT thstrm_amount as net_income
    FROM kr_financial_position
    WHERE symbol = $1
        AND sj_div = 'IS'
        AND account_nm IN ('ë‹¹ê¸°ìˆœì´ìµ(ì†ì‹¤)', 'ë‹¹ê¸°ìˆœì´ìµ')
        AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
    ORDER BY bsns_year DESC, rcept_dt DESC
    LIMIT 1
    """

    ni_result = await self.execute_query(net_income_query, self.symbol, self.analysis_date)

    if not ni_result or ni_result[0]['net_income'] is None:
        return None

    net_income = float(ni_result[0]['net_income'])

    # í‘ìë©´ ì´ ì „ëµ ì‚¬ìš© ì•ˆí•¨ (V1~V16 ì‚¬ìš©)
    if net_income > 0:
        return None

    # Step 2: ë§¤ì¶œ ë°ì´í„° ìˆ˜ì§‘ (ìµœê·¼ 3ë…„)
    sales_query = """
    WITH sales_data AS (
        SELECT
            bsns_year,
            thstrm_amount as sales,
            ROW_NUMBER() OVER (PARTITION BY bsns_year ORDER BY rcept_dt DESC) as rn
        FROM kr_financial_position
        WHERE symbol = $1
            AND sj_div = 'IS'
            AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
            AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            AND thstrm_amount > 0
        ORDER BY bsns_year DESC
    )
    SELECT bsns_year, sales
    FROM sales_data
    WHERE rn = 1
    ORDER BY bsns_year DESC
    LIMIT 3
    """

    sales_result = await self.execute_query(sales_query, self.symbol, self.analysis_date)

    if not sales_result or len(sales_result) < 2:
        return 0  # ë§¤ì¶œ ë°ì´í„° ë¶€ì¡±

    # Step 3: ì„±ì¥ë¥  ê³„ì‚°
    sales_current = float(sales_result[0]['sales'])
    sales_1y_ago = float(sales_result[1]['sales']) if len(sales_result) > 1 else None
    sales_3y_ago = float(sales_result[2]['sales']) if len(sales_result) > 2 else None

    # 1ë…„ ì„±ì¥ë¥ 
    if sales_1y_ago and sales_1y_ago > 0:
        sales_growth_1y = (sales_current - sales_1y_ago) / sales_1y_ago
    else:
        sales_growth_1y = 0

    # 3ë…„ CAGR
    if sales_3y_ago and sales_3y_ago > 0:
        sales_growth_3y = (sales_current / sales_3y_ago) ** (1/3) - 1
    else:
        sales_growth_3y = sales_growth_1y  # 3ë…„ ë°ì´í„° ì—†ìœ¼ë©´ 1ë…„ìœ¼ë¡œ ëŒ€ì²´

    # Step 4: ì˜ì—… ë§ˆì§„ ì¶”ì„¸
    margin_query = """
    WITH margin_data AS (
        SELECT
            bsns_year,
            op.thstrm_amount as operating_profit,
            sales.thstrm_amount as sales,
            (op.thstrm_amount::DECIMAL / NULLIF(sales.thstrm_amount, 0)) * 100 as operating_margin
        FROM kr_financial_position op
        JOIN kr_financial_position sales
            ON op.symbol = sales.symbol
            AND op.bsns_year = sales.bsns_year
            AND op.rcept_dt = sales.rcept_dt
        WHERE op.symbol = $1
            AND op.sj_div = 'IS'
            AND sales.sj_div = 'IS'
            AND op.account_nm IN ('ì˜ì—…ì´ìµ(ì†ì‹¤)', 'ì˜ì—…ì´ìµ')
            AND sales.account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
            AND op.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY bsns_year DESC
        LIMIT 2
    )
    SELECT operating_margin
    FROM margin_data
    ORDER BY bsns_year DESC
    """

    margin_result = await self.execute_query(margin_query, self.symbol, self.analysis_date)

    operating_margin_trend = 0
    if margin_result and len(margin_result) >= 2:
        margin_current = float(margin_result[0]['operating_margin']) if margin_result[0]['operating_margin'] else -999
        margin_prev = float(margin_result[1]['operating_margin']) if margin_result[1]['operating_margin'] else -999
        if margin_current > -999 and margin_prev > -999:
            operating_margin_trend = margin_current - margin_prev

    # Step 5: í˜„ê¸ˆ ì†Œì§„ìœ¨ (ìƒì¡´ ê°€ëŠ¥ì„±)
    cash_query = """
    WITH latest_cf AS (
        SELECT
            cf.thstrm_amount as operating_cash_flow,
            cash.thstrm_amount as cash_and_equivalents
        FROM kr_financial_position cf
        JOIN kr_financial_position cash
            ON cf.symbol = cash.symbol
            AND cf.bsns_year = cash.bsns_year
            AND cf.rcept_dt = cash.rcept_dt
        WHERE cf.symbol = $1
            AND cf.sj_div = 'CF'
            AND cash.sj_div = 'BS'
            AND cf.account_nm LIKE '%ì˜ì—…í™œë™%í˜„ê¸ˆíë¦„%'
            AND cash.account_nm LIKE '%í˜„ê¸ˆ%'
            AND cf.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY cf.bsns_year DESC, cf.rcept_dt DESC
        LIMIT 1
    )
    SELECT operating_cash_flow, cash_and_equivalents
    FROM latest_cf
    """

    cash_result = await self.execute_query(cash_query, self.symbol, self.analysis_date)

    months_of_runway = 999  # ê¸°ë³¸ê°’: ì¶©ë¶„
    if cash_result and cash_result[0]['operating_cash_flow'] and cash_result[0]['cash_and_equivalents']:
        ocf = float(cash_result[0]['operating_cash_flow'])
        cash = float(cash_result[0]['cash_and_equivalents'])
        if ocf < 0 and cash > 0:
            monthly_burn = abs(ocf) / 12
            if monthly_burn > 0:
                months_of_runway = cash / monthly_burn

    # Step 6: PSR (Price-to-Sales Ratio)
    psr_query = """
    SELECT
        kit.market_cap,
        fp.thstrm_amount as sales
    FROM kr_intraday_total kit
    LEFT JOIN (
        SELECT symbol, thstrm_amount
        FROM kr_financial_position
        WHERE symbol = $1
            AND sj_div = 'IS'
            AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
            AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY bsns_year DESC, rcept_dt DESC
        LIMIT 1
    ) fp ON kit.symbol = fp.symbol
    WHERE kit.symbol = $1
        AND ($2::date IS NULL OR kit.date = $2)
    ORDER BY kit.date DESC
    LIMIT 1
    """

    psr_result = await self.execute_query(psr_query, self.symbol, self.analysis_date)

    psr = None
    if psr_result and psr_result[0]['market_cap'] and psr_result[0]['sales']:
        market_cap = float(psr_result[0]['market_cap'])
        sales = float(psr_result[0]['sales'])
        if sales > 0:
            psr = market_cap / sales

    # Step 7: ì„¹í„° ì¤‘ì•™ê°’ PSR ê³„ì‚°
    sector_psr_query = """
    WITH sector_stocks AS (
        SELECT sd.symbol, sd.theme
        FROM kr_stock_detail sd
        WHERE sd.symbol = $1
    ),
    peer_psr AS (
        SELECT
            kit.symbol,
            kit.market_cap / NULLIF(fp.thstrm_amount, 0) as psr
        FROM kr_intraday_total kit
        JOIN kr_stock_detail sd ON kit.symbol = sd.symbol
        LEFT JOIN (
            SELECT DISTINCT ON (symbol)
                symbol, thstrm_amount
            FROM kr_financial_position
            WHERE sj_div = 'IS'
                AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY symbol, bsns_year DESC, rcept_dt DESC
        ) fp ON kit.symbol = fp.symbol
        WHERE sd.theme = (SELECT theme FROM sector_stocks)
            AND ($2::date IS NULL OR kit.date = $2)
            AND kit.market_cap > 0
            AND fp.thstrm_amount > 0
    )
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY psr) as median_psr
    FROM peer_psr
    WHERE psr > 0 AND psr < 100
    """

    sector_psr_result = await self.execute_query(sector_psr_query, self.symbol, self.analysis_date)

    sector_median_psr = 2.0  # ê¸°ë³¸ê°’
    if sector_psr_result and sector_psr_result[0]['median_psr']:
        sector_median_psr = float(sector_psr_result[0]['median_psr'])

    # Step 8: ì ìˆ˜ ê³„ì‚°
    score = 0

    # High Growth (ì´ˆê³ ì„±ì¥)
    if (sales_growth_3y > 0.50 and          # ì—° 50% ì´ìƒ ì„±ì¥
        sales_growth_1y > 0.30 and          # ìµœê·¼ë„ 30% ì´ìƒ
        operating_margin_trend > 0 and      # ë§ˆì§„ ê°œì„  ì¤‘
        months_of_runway > 12):             # 1ë…„ ì´ìƒ ìƒì¡´ ê°€ëŠ¥

        if psr and psr < sector_median_psr * 0.7:   # ì„¹í„° ëŒ€ë¹„ 30% í• ì¸
            score = 85  # ê³ ì„±ì¥ + ì €í‰ê°€ = ìµœê³  ì ìˆ˜
        elif psr and psr < sector_median_psr:
            score = 70
        else:
            score = 50  # ì„±ì¥í•˜ì§€ë§Œ ê³ í‰ê°€

    # Mid Growth (ì¤‘ì„±ì¥)
    elif (sales_growth_3y > 0.20 and
          sales_growth_1y > 0.10 and
          operating_margin_trend > -0.05 and
          months_of_runway > 6):

        if psr and psr < sector_median_psr * 0.8:
            score = 65
        elif psr and psr < sector_median_psr:
            score = 45
        else:
            score = 25

    # Low Growth / Troubled (ì €ì„±ì¥ / ìœ„í—˜)
    else:
        if months_of_runway < 6:
            score = 0   # ìƒì¡´ ìœ„í—˜
        elif sales_growth_1y < 0:
            score = 0   # ë§¤ì¶œ ì—­ì„±ì¥
        else:
            score = 10  # ìœ„í—˜í•˜ì§€ë§Œ ì¼ë‹¨ ìƒì¡´

    logger.info(f"V17 Score: {score:.1f} (Sales Growth 3Y: {sales_growth_3y*100:.1f}%, 1Y: {sales_growth_1y*100:.1f}%, Runway: {months_of_runway:.0f}M)")

    return score
```

#### Step 2: V1 í•¨ìˆ˜ ìˆ˜ì • (ì ì í´ë°±)

**ìœ„ì¹˜**: `kr\kr_value_factor.py` ë¼ì¸ 190-259 (ê¸°ì¡´ calculate_v1 í•¨ìˆ˜)

**ìˆ˜ì • ì „**:
```python
if per is None or per <= 0:
    return None  # âŒ None = 0ì  ì²˜ë¦¬
```

**ìˆ˜ì • í›„**:
```python
if per is None or per <= 0:
    # ì ì ê¸°ì—…: V17ë¡œ í´ë°±
    logger.info(f"V1: PER invalid ({per}), falling back to V17")
    return await self.calculate_v17_growth_adjusted_value()  # âœ… V17ë¡œ ìœ„ì„
```

**ì „ì²´ ìˆ˜ì • ì½”ë“œ**:
```python
async def calculate_v1(self):
    """
    V1. Low PER Strategy (Enhanced with V17 fallback)
    Description: Find undervalued stocks with low price-to-earnings ratio
    Score = 100 - MIN(100, MAX(0, (PER / 15) Ã— 50))
    Condition: PER > 0 (í‘ì), PER <= 0 (V17ë¡œ í´ë°±)
    Interpretation: PER <= 15 gets 100 points, PER >= 30 gets 0 points
    """
    query = """
    SELECT per
    FROM kr_intraday_detail
    WHERE symbol = $1
    """

    result = await self.execute_query(query, self.symbol)
    per = None

    # Try to get PER from kr_intraday_detail first
    if result and result[0]['per'] is not None and result[0]['per'] > 0:
        per = float(result[0]['per'])

    # Fallback: Calculate PER from market cap and net income
    if per is None:
        fallback_query = """
        SELECT
            kit.market_cap,
            fp.thstrm_amount as net_income
        FROM kr_intraday_total kit
        LEFT JOIN (
            SELECT symbol, thstrm_amount
            FROM kr_financial_position
            WHERE symbol = $1
                AND sj_div = 'IS'
                AND account_nm IN ('ë‹¹ê¸°ìˆœì´ìµ(ì†ì‹¤)', 'ë‹¹ê¸°ìˆœì´ìµ')
                AND thstrm_amount > 0
                AND rcept_dt <= COALESCE($3::date, CURRENT_DATE)
            ORDER BY
                bsns_year DESC,
                rcept_dt DESC,
                CASE
                    WHEN report_code = '11011' THEN 1
                    WHEN report_code = '11012' THEN 2
                    WHEN report_code = '11013' THEN 3
                    WHEN report_code = '11014' THEN 4
                    ELSE 5
                END,
                thstrm_amount DESC
            LIMIT 1
        ) fp ON kit.symbol = fp.symbol
        WHERE kit.symbol = $2
            AND ($3::date IS NULL OR kit.date = $3)
        ORDER BY kit.date DESC
        LIMIT 1
        """

        fallback_result = await self.execute_query(fallback_query, self.symbol, self.symbol, self.analysis_date)

        if fallback_result and fallback_result[0]['market_cap'] and fallback_result[0]['net_income']:
            mktcap = float(fallback_result[0]['market_cap'])
            net_income = float(fallback_result[0]['net_income'])
            if net_income > 0 and mktcap > 0:
                per = mktcap / net_income

    # ì ì ê¸°ì—… ì²˜ë¦¬: V17ë¡œ í´ë°±
    if per is None or per <= 0:
        logger.info(f"V1: PER invalid ({per}), falling back to V17 (Growth-Adjusted Value)")
        return await self.calculate_v17_growth_adjusted_value()

    # í‘ì ê¸°ì—…: ê¸°ì¡´ ë¡œì§
    score = 100 - min(100, max(0, (per / 15) * 50))

    return score
```

---

### Task 1.2: V4 - ì§€ì† ê°€ëŠ¥ ë°°ë‹¹ ì „ëµ ì¬ì„¤ê³„

**ëª©í‘œ**: ë‹¨ìˆœ ë°°ë‹¹ë¥ ì´ ì•„ë‹Œ ë°°ë‹¹ ì§€ì† ê°€ëŠ¥ì„± í‰ê°€

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

#### Step 1: ê¸°ì¡´ V4 ë°±ì—…

**ìœ„ì¹˜**: `kr\kr_value_factor.py` ë¼ì¸ 700ëŒ€ (ê¸°ì¡´ calculate_v4 í•¨ìˆ˜ ì°¾ê¸°)

**ë°±ì—… ì½”ë“œ**:
```python
async def calculate_v4_original(self):
    """
    V4. High Dividend Yield Strategy (ORIGINAL - DEPRECATED)

    Original IC: -0.057
    This version for comparison only
    """
    # ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ ìœ ì§€ (ì´ë¦„ë§Œ ë³€ê²½)
```

#### Step 2: V4 ì¬ì„¤ê³„ êµ¬í˜„

**ìœ„ì¹˜**: ê¸°ì¡´ calculate_v4 í•¨ìˆ˜ êµì²´

```python
async def calculate_v4_sustainable_dividend(self):
    """
    V4. Sustainable Dividend Strategy (ì¬ì„¤ê³„)

    Description: ì§€ì† ê°€ëŠ¥í•œ ë°°ë‹¹ í‰ê°€

    Components:
    1. Payout Ratio (ë°°ë‹¹ì„±í–¥): >80% = ìœ„í—˜
    2. FCF Coverage (í˜„ê¸ˆíë¦„ ì»¤ë²„ë¦¬ì§€): FCF < Dividend = ìœ„í—˜
    3. Dividend Growth (ë°°ë‹¹ ì„±ì¥): 3ë…„ CAGR
    4. Dividend Yield: ìµœì¢… í‰ê°€

    Scoring Logic:
    - ìœ„í—˜ ì‹ í˜¸ íƒì§€: Payout >80%, FCF < Div, Div ê°ì†Œ â†’ 10-20ì 
    - ìš°ìˆ˜ ë°°ë‹¹: ì„±ì¥ >5%, Payout <50%, FCF >1.5x â†’ 75-90ì 
    - ì•ˆì • ë°°ë‹¹: ìœ ì§€, Payout <60%, FCF >1.2x â†’ 40-70ì 
    """

    # Step 1: ë°°ë‹¹ ë°ì´í„° ìˆ˜ì§‘
    dividend_query = """
    WITH latest_dividend AS (
        SELECT
            thstrm as current_dividend,
            frmtrm as prev_dividend,
            lwfr as prev2_dividend,
            stlm_dt
        FROM kr_dividends
        WHERE symbol = $1
            AND se LIKE '%ë°°ë‹¹%'
            AND stock_knd LIKE '%ë³´í†µì£¼%'
            AND stlm_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY stlm_dt DESC
        LIMIT 1
    )
    SELECT * FROM latest_dividend
    """

    div_result = await self.execute_query(dividend_query, self.symbol, self.analysis_date)

    if not div_result or div_result[0]['current_dividend'] is None:
        return None  # ë°°ë‹¹ ë°ì´í„° ì—†ìŒ

    current_dividend = float(div_result[0]['current_dividend']) if div_result[0]['current_dividend'] else 0
    prev_dividend = float(div_result[0]['prev_dividend']) if div_result[0]['prev_dividend'] else 0
    prev2_dividend = float(div_result[0]['prev2_dividend']) if div_result[0]['prev2_dividend'] else 0

    if current_dividend <= 0:
        return None  # ë¬´ë°°ë‹¹

    # Step 2: ì£¼ê°€ ë° ë°°ë‹¹ ìˆ˜ìµë¥ 
    price_query = """
    SELECT close
    FROM kr_intraday_total
    WHERE symbol = $1
        AND ($2::date IS NULL OR date = $2)
    ORDER BY date DESC
    LIMIT 1
    """

    price_result = await self.execute_query(price_query, self.symbol, self.analysis_date)

    if not price_result or not price_result[0]['close']:
        return None

    price = float(price_result[0]['close'])
    dividend_yield = (current_dividend / price) * 100 if price > 0 else 0

    # Step 3: Payout Ratio (ë°°ë‹¹ì„±í–¥)
    payout_query = """
    WITH latest_financials AS (
        SELECT
            ni.thstrm_amount as net_income,
            eps.close as eps,
            eps.listed_shares
        FROM kr_financial_position ni
        LEFT JOIN kr_intraday_total eps ON ni.symbol = eps.symbol
        WHERE ni.symbol = $1
            AND ni.sj_div = 'IS'
            AND ni.account_nm IN ('ë‹¹ê¸°ìˆœì´ìµ(ì†ì‹¤)', 'ë‹¹ê¸°ìˆœì´ìµ')
            AND ni.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            AND ($2::date IS NULL OR eps.date = $2)
        ORDER BY ni.bsns_year DESC, ni.rcept_dt DESC, eps.date DESC
        LIMIT 1
    )
    SELECT net_income, listed_shares
    FROM latest_financials
    """

    payout_result = await self.execute_query(payout_query, self.symbol, self.analysis_date)

    payout_ratio = 999  # ê¸°ë³¸ê°’: ì•Œ ìˆ˜ ì—†ìŒ (ë³´ìˆ˜ì )
    if payout_result and payout_result[0]['net_income'] and payout_result[0]['listed_shares']:
        net_income = float(payout_result[0]['net_income'])
        listed_shares = float(payout_result[0]['listed_shares'])
        if net_income > 0 and listed_shares > 0:
            total_dividend = current_dividend * listed_shares
            payout_ratio = (total_dividend / net_income) * 100

    # Step 4: FCF Coverage (ì‰ì—¬í˜„ê¸ˆíë¦„ ì»¤ë²„ë¦¬ì§€)
    fcf_query = """
    WITH latest_cf AS (
        SELECT
            ocf.thstrm_amount as operating_cash_flow,
            inv.thstrm_amount as capex
        FROM kr_financial_position ocf
        LEFT JOIN kr_financial_position inv
            ON ocf.symbol = inv.symbol
            AND ocf.bsns_year = inv.bsns_year
            AND ocf.rcept_dt = inv.rcept_dt
            AND inv.sj_div = 'CF'
            AND inv.account_nm LIKE '%íˆ¬ìí™œë™%í˜„ê¸ˆíë¦„%'
        WHERE ocf.symbol = $1
            AND ocf.sj_div = 'CF'
            AND ocf.account_nm LIKE '%ì˜ì—…í™œë™%í˜„ê¸ˆíë¦„%'
            AND ocf.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY ocf.bsns_year DESC, ocf.rcept_dt DESC
        LIMIT 1
    )
    SELECT operating_cash_flow, capex
    FROM latest_cf
    """

    fcf_result = await self.execute_query(fcf_query, self.symbol, self.analysis_date)

    fcf_coverage = 0  # ê¸°ë³¸ê°’: ì»¤ë²„ ì•ˆë¨ (ë³´ìˆ˜ì )
    if fcf_result and fcf_result[0]['operating_cash_flow']:
        ocf = float(fcf_result[0]['operating_cash_flow'])
        capex = float(fcf_result[0]['capex']) if fcf_result[0]['capex'] else 0
        fcf = ocf - abs(capex)  # FCF = OCF - CapEx

        # ì´ ë°°ë‹¹ê¸ˆ ê³„ì‚°
        if payout_result and payout_result[0]['listed_shares']:
            listed_shares = float(payout_result[0]['listed_shares'])
            total_dividend = current_dividend * listed_shares
            if total_dividend > 0:
                fcf_coverage = fcf / total_dividend

    # Step 5: ë°°ë‹¹ ì„±ì¥ë¥  (3ë…„ CAGR)
    dividend_growth = 0
    if prev2_dividend > 0:
        dividend_growth = (current_dividend / prev2_dividend) ** (1/3) - 1
    elif prev_dividend > 0:
        dividend_growth = (current_dividend / prev_dividend) - 1

    # Step 6: ì ìˆ˜ ê³„ì‚°
    score = 0

    # === ìœ„í—˜ ì‹ í˜¸ íƒì§€ ===

    # ìœ„í—˜ 1: ê³¼ë„í•œ ë°°ë‹¹ (Payout Ratio > 80%)
    if payout_ratio > 80:
        logger.info(f"V4 WARNING: High payout ratio {payout_ratio:.1f}%")
        return 10  # ì§€ì† ë¶ˆê°€ëŠ¥

    # ìœ„í—˜ 2: FCF < ë°°ë‹¹ (ë¹šë‚´ì„œ ë°°ë‹¹)
    if fcf_coverage < 1.0:
        logger.info(f"V4 WARNING: FCF coverage {fcf_coverage:.2f}x < 1.0")
        return 15  # ìœ„í—˜

    # ìœ„í—˜ 3: ë°°ë‹¹ ê°ì†Œ ì¶”ì„¸
    if dividend_growth < -0.05:
        logger.info(f"V4 WARNING: Dividend declining {dividend_growth*100:.1f}%")
        return 20  # ë°°ë‹¹ ì»· ìœ„í—˜

    # === ê¸ì • ì‹ í˜¸ í‰ê°€ ===

    # ìš°ìˆ˜: ë°°ë‹¹ ì¦ê°€ + ì—¬ìœ  ìˆìŒ
    if (dividend_growth > 0.05 and
        payout_ratio < 50 and
        fcf_coverage > 1.5):

        # ë°°ë‹¹ ìˆ˜ìµë¥  ê¸°ë°˜ ì ìˆ˜
        if dividend_yield > 4.0:      # 4% ì´ìƒ
            score = 90
        elif dividend_yield > 3.0:    # 3% ì´ìƒ
            score = 75
        else:
            score = 60

        logger.info(f"V4: Excellent dividend (Yield: {dividend_yield:.2f}%, Growth: {dividend_growth*100:.1f}%)")

    # ì–‘í˜¸: ì•ˆì •ì 
    elif (payout_ratio < 60 and
          fcf_coverage > 1.2 and
          dividend_growth > -0.02):

        if dividend_yield > 3.0:
            score = 70
        elif dividend_yield > 2.0:
            score = 55
        else:
            score = 40

        logger.info(f"V4: Stable dividend (Yield: {dividend_yield:.2f}%, Payout: {payout_ratio:.1f}%)")

    # ë³´í†µ
    else:
        if dividend_yield > 3.0:
            score = 50
        else:
            score = 30

        logger.info(f"V4: Moderate dividend (Yield: {dividend_yield:.2f}%)")

    return score

# Alias for backward compatibility
async def calculate_v4(self):
    """V4 wrapper - calls sustainable dividend version"""
    return await self.calculate_v4_sustainable_dividend()
```

---

### Task 1.3: V18 - EV/Sales/Growth ì „ëµ ì¶”ê°€ (V9 ëŒ€ì²´)

**ëª©í‘œ**: ë‹¨ìˆœ EV/Salesê°€ ì•„ë‹Œ ì„±ì¥ë¥ ë¡œ ì¡°ì •ëœ ë°¸ë¥˜ì—ì´ì…˜

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

#### Step 1: V9 ë°±ì—…

```python
async def calculate_v9_original(self):
    """
    V9. Low EV/Sales Strategy (ORIGINAL)

    Original IC: +0.055 (ìœ ì¼í•œ ì–‘ìˆ˜ì§€ë§Œ ì•½í•¨)
    This version for comparison only
    """
    # ê¸°ì¡´ ì½”ë“œ ìœ ì§€
```

#### Step 2: V18 ì¶”ê°€

**ìœ„ì¹˜**: `kr\kr_value_factor.py` í•˜ë‹¨

```python
# ========================================================================
# V18. EV/Sales with Growth Adjustment (V9 ê°œì„  ë²„ì „)
# ========================================================================

async def calculate_v18_ev_sales_growth(self):
    """
    V18. EV/Sales/Growth Strategy (V9 ê°œì„ )

    Description: ì„±ì¥ë¥ ë¡œ ì¡°ì •ëœ EV/Sales

    Logic:
    - EV/Sales/Growth = (EV/Sales) / (Sales Growth Rate)
    - PEG ë¹„ìœ¨ê³¼ ìœ ì‚¬í•œ ê°œë…
    - ì„±ì¥ 1%ë‹¹ EV/Sales = "ì„±ì¥ ë³´ì • ë°¸ë¥˜ì—ì´ì…˜"

    Scoring:
    - ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ (ê³ ì„±ì¥ ì €í‰ê°€)
    - ì„¹í„° ë‚´ ìƒëŒ€ í‰ê°€
    """

    # Step 1: Enterprise Value ê³„ì‚°
    ev_query = """
    WITH latest_data AS (
        SELECT
            kit.market_cap,
            fp_debt.thstrm_amount as total_debt,
            fp_cash.thstrm_amount as cash
        FROM kr_intraday_total kit
        LEFT JOIN (
            SELECT symbol, thstrm_amount
            FROM kr_financial_position
            WHERE symbol = $1
                AND sj_div = 'BS'
                AND account_nm LIKE '%ë¶€ì±„%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY bsns_year DESC, rcept_dt DESC
            LIMIT 1
        ) fp_debt ON kit.symbol = fp_debt.symbol
        LEFT JOIN (
            SELECT symbol, thstrm_amount
            FROM kr_financial_position
            WHERE symbol = $1
                AND sj_div = 'BS'
                AND account_nm LIKE '%í˜„ê¸ˆ%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY bsns_year DESC, rcept_dt DESC
            LIMIT 1
        ) fp_cash ON kit.symbol = fp_cash.symbol
        WHERE kit.symbol = $1
            AND ($2::date IS NULL OR kit.date = $2)
        ORDER BY kit.date DESC
        LIMIT 1
    )
    SELECT market_cap, total_debt, cash
    FROM latest_data
    """

    ev_result = await self.execute_query(ev_query, self.symbol, self.analysis_date)

    if not ev_result or not ev_result[0]['market_cap']:
        return None

    market_cap = float(ev_result[0]['market_cap'])
    total_debt = float(ev_result[0]['total_debt']) if ev_result[0]['total_debt'] else 0
    cash = float(ev_result[0]['cash']) if ev_result[0]['cash'] else 0

    enterprise_value = market_cap + total_debt - cash

    if enterprise_value <= 0:
        return None

    # Step 2: Sales ë° ì„±ì¥ë¥ 
    sales_query = """
    WITH sales_history AS (
        SELECT
            bsns_year,
            thstrm_amount as sales,
            ROW_NUMBER() OVER (PARTITION BY bsns_year ORDER BY rcept_dt DESC) as rn
        FROM kr_financial_position
        WHERE symbol = $1
            AND sj_div = 'IS'
            AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
            AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY bsns_year DESC
    )
    SELECT bsns_year, sales
    FROM sales_history
    WHERE rn = 1
    ORDER BY bsns_year DESC
    LIMIT 3
    """

    sales_result = await self.execute_query(sales_query, self.symbol, self.analysis_date)

    if not sales_result or len(sales_result) < 2:
        return None

    sales_current = float(sales_result[0]['sales'])
    sales_3y_ago = float(sales_result[2]['sales']) if len(sales_result) > 2 else float(sales_result[1]['sales'])

    if sales_current <= 0 or sales_3y_ago <= 0:
        return None

    # 3ë…„ CAGR
    years = 3 if len(sales_result) > 2 else 2
    sales_growth_rate = (sales_current / sales_3y_ago) ** (1/years) - 1

    # Step 3: EV/Sales ê³„ì‚°
    ev_sales = enterprise_value / sales_current

    # Step 4: EV/Sales/Growth ê³„ì‚°
    if sales_growth_rate > 0.05:  # ìµœì†Œ 5% ì„±ì¥
        ev_sales_growth = ev_sales / (sales_growth_rate * 100)
    else:
        # ì €ì„±ì¥ (<5%): í˜ë„í‹°
        ev_sales_growth = ev_sales * 10  # ë†’ì€ ê°’ = ë‚˜ì¨

    # Step 5: ì„¹í„° ë‚´ ë°±ë¶„ìœ„ ê³„ì‚°
    sector_query = """
    WITH sector_stocks AS (
        SELECT sd.symbol, sd.theme
        FROM kr_stock_detail sd
        WHERE sd.symbol = $1
    ),
    peer_ev_sales_growth AS (
        SELECT
            kit.symbol,
            (kit.market_cap + COALESCE(debt.thstrm_amount, 0) - COALESCE(cash.thstrm_amount, 0)) /
            NULLIF(sales_current.thstrm_amount, 0) as ev_sales,
            CASE
                WHEN sales_growth.growth_rate > 0.05 THEN
                    ((kit.market_cap + COALESCE(debt.thstrm_amount, 0) - COALESCE(cash.thstrm_amount, 0)) /
                     NULLIF(sales_current.thstrm_amount, 0)) / (sales_growth.growth_rate * 100)
                ELSE
                    ((kit.market_cap + COALESCE(debt.thstrm_amount, 0) - COALESCE(cash.thstrm_amount, 0)) /
                     NULLIF(sales_current.thstrm_amount, 0)) * 10
            END as ev_sales_growth_metric
        FROM kr_intraday_total kit
        JOIN kr_stock_detail sd ON kit.symbol = sd.symbol
        LEFT JOIN (
            SELECT DISTINCT ON (symbol) symbol, thstrm_amount
            FROM kr_financial_position
            WHERE sj_div = 'BS' AND account_nm LIKE '%ë¶€ì±„%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY symbol, bsns_year DESC, rcept_dt DESC
        ) debt ON kit.symbol = debt.symbol
        LEFT JOIN (
            SELECT DISTINCT ON (symbol) symbol, thstrm_amount
            FROM kr_financial_position
            WHERE sj_div = 'BS' AND account_nm LIKE '%í˜„ê¸ˆ%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY symbol, bsns_year DESC, rcept_dt DESC
        ) cash ON kit.symbol = cash.symbol
        LEFT JOIN (
            SELECT DISTINCT ON (symbol) symbol, thstrm_amount
            FROM kr_financial_position
            WHERE sj_div = 'IS' AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY symbol, bsns_year DESC, rcept_dt DESC
        ) sales_current ON kit.symbol = sales_current.symbol
        LEFT JOIN (
            SELECT
                symbol,
                (MAX(thstrm_amount) / MIN(thstrm_amount)) ^ (1.0/2) - 1 as growth_rate
            FROM kr_financial_position
            WHERE sj_div = 'IS' AND account_nm IN ('ë§¤ì¶œì•¡', 'ìˆ˜ìµ(ë§¤ì¶œì•¡)')
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
                AND bsns_year >= EXTRACT(YEAR FROM COALESCE($2::date, CURRENT_DATE)) - 3
            GROUP BY symbol
            HAVING COUNT(*) >= 2
        ) sales_growth ON kit.symbol = sales_growth.symbol
        WHERE sd.theme = (SELECT theme FROM sector_stocks)
            AND ($2::date IS NULL OR kit.date = $2)
            AND kit.market_cap > 0
            AND sales_current.thstrm_amount > 0
    )
    SELECT PERCENTILE_CONT(ARRAY[0.25, 0.5, 0.75]) WITHIN GROUP (ORDER BY ev_sales_growth_metric) as percentiles
    FROM peer_ev_sales_growth
    WHERE ev_sales_growth_metric > 0 AND ev_sales_growth_metric < 100
    """

    percentile_result = await self.execute_query(sector_query, self.symbol, self.analysis_date)

    # ë°±ë¶„ìœ„ ê¸°ë°˜ ì ìˆ˜
    if percentile_result and percentile_result[0]['percentiles']:
        percentiles = percentile_result[0]['percentiles']
        p25, p50, p75 = percentiles[0], percentiles[1], percentiles[2]

        if ev_sales_growth < p25:
            score = 90  # í•˜ìœ„ 25% = ìµœê³  (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        elif ev_sales_growth < p50:
            score = 70  # ì¤‘ì•™ê°’ ì´í•˜
        elif ev_sales_growth < p75:
            score = 50  # ì¤‘ì•™ê°’ ì´ìƒ
        else:
            score = 30  # ìƒìœ„ 25%
    else:
        # ì ˆëŒ€ í‰ê°€ í´ë°±
        if ev_sales_growth < 2:
            score = 80
        elif ev_sales_growth < 5:
            score = 60
        elif ev_sales_growth < 10:
            score = 40
        else:
            score = 20

    logger.info(f"V18: EV/Sales/Growth = {ev_sales_growth:.2f} (EV/Sales: {ev_sales:.2f}, Growth: {sales_growth_rate*100:.1f}%), Score: {score:.1f}")

    return score
```

---

### Task 1.4: V20 - ROIC-Based Value ì¶”ê°€ (V6 ëŒ€ì²´)

**ëª©í‘œ**: ROE+PER ë‹¨ìˆœ ê²°í•©ì´ ì•„ë‹Œ ìë³¸ íš¨ìœ¨ì„± ê¸°ë°˜ í‰ê°€

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

#### Step 1: V6 ë°±ì—…

```python
async def calculate_v6_original(self):
    """
    V6. High ROE + Low PER Strategy (ORIGINAL)

    Original IC: +0.030 (ë§¤ìš° ì•½í•¨)
    This version for comparison only
    """
    # ê¸°ì¡´ ì½”ë“œ ìœ ì§€
```

#### Step 2: V20 ì¶”ê°€

```python
# ========================================================================
# V20. ROIC-Based Value (V6 ê°œì„  ë²„ì „)
# ========================================================================

async def calculate_v20_roic_value(self):
    """
    V20. ROIC-Based Value Strategy (V6 ê°œì„ )

    Description: ìë³¸ íš¨ìœ¨ì„± ê¸°ë°˜ ë°¸ë¥˜ í‰ê°€

    Components:
    1. ROIC (Return on Invested Capital): NOPAT / Invested Capital
    2. EV/IC (Enterprise Value / Invested Capital)
    3. Magic Ratio: ROIC / (EV/IC)

    Logic:
    - ROIC: íˆ¬ì… ìë³¸ ëŒ€ë¹„ ìˆ˜ìµì„± (ROEë³´ë‹¤ ì •í™•)
    - EV/IC: ì‹œì¥ì´ ìë³¸ì„ ì–¼ë§ˆë¡œ í‰ê°€í•˜ëŠ”ê°€
    - Magic Ratio ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ = íš¨ìœ¨ì ì¸ë° ì €í‰ê°€

    Scoring:
    - ROIC >15% & EV/IC <1.5: 90ì  (ì§„ì§œ ì €í‰ê°€)
    - ROIC >15% & EV/IC >2.5: 40ì  (ì¢‹ì§€ë§Œ ë¹„ìŒˆ)
    - ROIC <5% & EV/IC <1.5: 20ì  (Value Trap)
    """

    # Step 1: NOPAT (Net Operating Profit After Tax)
    nopat_query = """
    WITH latest_is AS (
        SELECT
            op.thstrm_amount as operating_profit,
            tax.thstrm_amount as tax_expense,
            ni.thstrm_amount as net_income
        FROM kr_financial_position op
        LEFT JOIN kr_financial_position tax
            ON op.symbol = tax.symbol
            AND op.bsns_year = tax.bsns_year
            AND op.rcept_dt = tax.rcept_dt
            AND tax.sj_div = 'IS'
            AND tax.account_nm LIKE '%ë²•ì¸ì„¸%'
        LEFT JOIN kr_financial_position ni
            ON op.symbol = ni.symbol
            AND op.bsns_year = ni.bsns_year
            AND op.rcept_dt = ni.rcept_dt
            AND ni.sj_div = 'IS'
            AND ni.account_nm IN ('ë‹¹ê¸°ìˆœì´ìµ(ì†ì‹¤)', 'ë‹¹ê¸°ìˆœì´ìµ')
        WHERE op.symbol = $1
            AND op.sj_div = 'IS'
            AND op.account_nm IN ('ì˜ì—…ì´ìµ(ì†ì‹¤)', 'ì˜ì—…ì´ìµ')
            AND op.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY op.bsns_year DESC, op.rcept_dt DESC
        LIMIT 1
    )
    SELECT operating_profit, tax_expense, net_income
    FROM latest_is
    """

    nopat_result = await self.execute_query(nopat_query, self.symbol, self.analysis_date)

    if not nopat_result or not nopat_result[0]['operating_profit']:
        return None

    operating_profit = float(nopat_result[0]['operating_profit'])
    tax_expense = float(nopat_result[0]['tax_expense']) if nopat_result[0]['tax_expense'] else 0
    net_income = float(nopat_result[0]['net_income']) if nopat_result[0]['net_income'] else 0

    # Tax Rate ê³„ì‚°
    if net_income != 0:
        tax_rate = abs(tax_expense) / (net_income + abs(tax_expense))
    else:
        tax_rate = 0.25  # ê¸°ë³¸ ë²•ì¸ì„¸ìœ¨

    # NOPAT = Operating Profit Ã— (1 - Tax Rate)
    nopat = operating_profit * (1 - tax_rate)

    # Step 2: Invested Capital = Total Assets - Current Liabilities
    ic_query = """
    WITH latest_bs AS (
        SELECT
            assets.thstrm_amount as total_assets,
            cl.thstrm_amount as current_liabilities
        FROM kr_financial_position assets
        LEFT JOIN kr_financial_position cl
            ON assets.symbol = cl.symbol
            AND assets.bsns_year = cl.bsns_year
            AND assets.rcept_dt = cl.rcept_dt
            AND cl.sj_div = 'BS'
            AND cl.account_nm LIKE '%ìœ ë™ë¶€ì±„%'
        WHERE assets.symbol = $1
            AND assets.sj_div = 'BS'
            AND assets.account_nm LIKE '%ìì‚°ì´ê³„%'
            AND assets.rcept_dt <= COALESCE($2::date, CURRENT_DATE)
        ORDER BY assets.bsns_year DESC, assets.rcept_dt DESC
        LIMIT 1
    )
    SELECT total_assets, current_liabilities
    FROM latest_bs
    """

    ic_result = await self.execute_query(ic_query, self.symbol, self.analysis_date)

    if not ic_result or not ic_result[0]['total_assets']:
        return None

    total_assets = float(ic_result[0]['total_assets'])
    current_liabilities = float(ic_result[0]['current_liabilities']) if ic_result[0]['current_liabilities'] else 0

    invested_capital = total_assets - current_liabilities

    if invested_capital <= 0:
        return None

    # Step 3: ROIC ê³„ì‚°
    roic = (nopat / invested_capital) * 100

    # Step 4: Enterprise Value
    ev_query = """
    WITH latest_data AS (
        SELECT
            kit.market_cap,
            debt.thstrm_amount as total_debt,
            cash.thstrm_amount as cash
        FROM kr_intraday_total kit
        LEFT JOIN (
            SELECT symbol, thstrm_amount
            FROM kr_financial_position
            WHERE symbol = $1
                AND sj_div = 'BS'
                AND account_nm LIKE '%ë¶€ì±„ì´ê³„%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY bsns_year DESC, rcept_dt DESC
            LIMIT 1
        ) debt ON kit.symbol = debt.symbol
        LEFT JOIN (
            SELECT symbol, thstrm_amount
            FROM kr_financial_position
            WHERE symbol = $1
                AND sj_div = 'BS'
                AND account_nm LIKE '%í˜„ê¸ˆ%'
                AND rcept_dt <= COALESCE($2::date, CURRENT_DATE)
            ORDER BY bsns_year DESC, rcept_dt DESC
            LIMIT 1
        ) cash ON kit.symbol = cash.symbol
        WHERE kit.symbol = $1
            AND ($2::date IS NULL OR kit.date = $2)
        ORDER BY kit.date DESC
        LIMIT 1
    )
    SELECT market_cap, total_debt, cash
    FROM latest_data
    """

    ev_result = await self.execute_query(ev_query, self.symbol, self.analysis_date)

    if not ev_result or not ev_result[0]['market_cap']:
        return None

    market_cap = float(ev_result[0]['market_cap'])
    total_debt = float(ev_result[0]['total_debt']) if ev_result[0]['total_debt'] else 0
    cash = float(ev_result[0]['cash']) if ev_result[0]['cash'] else 0

    enterprise_value = market_cap + total_debt - cash

    if enterprise_value <= 0:
        return None

    # Step 5: EV/IC ê³„ì‚°
    ev_ic = enterprise_value / invested_capital

    # Step 6: Magic Ratio
    if ev_ic > 0:
        magic_ratio = roic / ev_ic
    else:
        magic_ratio = 0

    # Step 7: ì ìˆ˜ ê³„ì‚°
    score = 0

    # A. ë†’ì€ ROIC + ë‚®ì€ EV/IC = "ì§„ì§œ ì €í‰ê°€"
    if roic > 15 and ev_ic < 1.5:
        score = 90
        logger.info(f"V20: Excellent (ROIC: {roic:.1f}%, EV/IC: {ev_ic:.2f})")

    # B. ë†’ì€ ROIC + ë†’ì€ EV/IC = "ì¢‹ì§€ë§Œ ë¹„ìŒˆ"
    elif roic > 15 and ev_ic > 2.5:
        score = 40
        logger.info(f"V20: Good but expensive (ROIC: {roic:.1f}%, EV/IC: {ev_ic:.2f})")

    # C. ë‚®ì€ ROIC + ë‚®ì€ EV/IC = "Value Trap"
    elif roic < 5 and ev_ic < 1.5:
        score = 20
        logger.info(f"V20: Value Trap (ROIC: {roic:.1f}%, EV/IC: {ev_ic:.2f})")

    # D. ì¤‘ê°„ ë²”ìœ„: Magic Ratio ê¸°ë°˜
    else:
        # Magic Ratio ë°±ë¶„ìœ„ ì ìˆ˜
        if magic_ratio > 10:
            score = 85
        elif magic_ratio > 5:
            score = 70
        elif magic_ratio > 2:
            score = 55
        elif magic_ratio > 1:
            score = 40
        else:
            score = 25

        logger.info(f"V20: Magic Ratio {magic_ratio:.2f} (ROIC: {roic:.1f}%, EV/IC: {ev_ic:.2f})")

    return score
```

---

### Task 1.5: calculate_all_strategies() í•¨ìˆ˜ ì—…ë°ì´íŠ¸

**ìœ„ì¹˜**: `kr\kr_value_factor.py` (calculate_all_strategies í•¨ìˆ˜)

**ìˆ˜ì • ë‚´ìš©**:

```python
async def calculate_all_strategies(self):
    """
    Calculate all 20 value strategies (16 original + 4 new)

    Returns dict with strategy scores and weighted result
    """

    logger.info(f"Calculating value strategies for {self.symbol}...")

    # Original strategies (V1-V16)
    strategies_tasks = {
        'V1_Low_PER': self.calculate_v1(),  # âœ… V17 í´ë°± í¬í•¨
        'V2_Magic_Formula': self.calculate_v2(),  # DEPRECATED
        'V3_Low_PBR': self.calculate_v3(),
        'V4_High_Dividend': self.calculate_v4(),  # âœ… ì¬ì„¤ê³„ë¨
        'V5_Low_PSR': None,  # DEPRECATED
        'V6_High_ROE_Low_PER': None,  # V20ë¡œ ëŒ€ì²´
        'V7_Low_PCR': self.calculate_v7(),
        'V8_FCF_Yield': self.calculate_v8(),
        'V9_Low_EV_Sales': None,  # V18ë¡œ ëŒ€ì²´
        'V10_Low_Debt_Equity': self.calculate_v10(),
        'V11_High_Current_Ratio': self.calculate_v11(),
        'V12_ROE_PBR_Combined': self.calculate_v12(),
        'V13_Low_EV_EBITDA': self.calculate_v13(),
        'V14_Graham_Number': self.calculate_v14(),
        'V15_PEG_Ratio': self.calculate_v15(),
        'V16_Buffett_Indicator': self.calculate_v16(),
    }

    # New strategies (V17-V20)
    strategies_tasks.update({
        'V17_Growth_Adjusted': self.calculate_v17_growth_adjusted_value(),  # âœ… ì‹ ê·œ
        'V18_EV_Sales_Growth': self.calculate_v18_ev_sales_growth(),  # âœ… ì‹ ê·œ (V9 ëŒ€ì²´)
        'V19_Value_Momentum': None,  # TODO: Phase 2
        'V20_ROIC_Value': self.calculate_v20_roic_value(),  # âœ… ì‹ ê·œ (V6 ëŒ€ì²´)
    })

    # Execute all strategies concurrently
    results = {}
    for name, task in strategies_tasks.items():
        if task is not None:
            try:
                results[name] = await task
            except Exception as e:
                logger.error(f"Strategy {name} failed: {e}")
                results[name] = None
        else:
            results[name] = None

    self.strategies_scores = results

    # Get market state weights
    weights = self._get_strategy_weights()

    # Calculate weighted average
    weighted_result = self._calculate_weighted_average(results, weights)

    return {
        'strategies': results,
        'weighted_result': weighted_result,
        'market_state': self.market_state
    }
```

---

## Phase 2: ì¤‘ê¸° ê°œì„  (2-4ì£¼)

### Task 2.1: V19 - Value Momentum ì „ëµ ì¶”ê°€

**ëª©í‘œ**: ë°¸ë¥˜ì—ì´ì…˜ ì¶”ì„¸ í‰ê°€ (ì •ì  ë°¸ë¥˜ì—ì´ì…˜ â†’ ë™ì  ë°¸ë¥˜ì—ì´ì…˜)

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

```python
# ========================================================================
# V19. Value Momentum (ì‹ ê·œ)
# ========================================================================

async def calculate_v19_value_momentum(self):
    """
    V19. Value Momentum Strategy

    Description: ë°¸ë¥˜ì—ì´ì…˜ ê°œì„  ì¶”ì„¸ í‰ê°€

    Logic:
    - PER/PBRì´ í•˜ë½í•˜ë©´ì„œ (ë°¸ë¥˜ ê°œì„ )
    - ì£¼ê°€ëŠ” ìƒìŠ¹í•˜ë©´ (ì‹œì¥ì´ ì¸ì •)
    - = ì§„ì§œ ë°¸ë¥˜

    Scenarios:
    A. ë°¸ë¥˜ ê°œì„  + ì£¼ê°€ ìƒìŠ¹ = 90ì  (ì‹œì¥ì´ ì¸ì • ì‹œì‘)
    B. ë°¸ë¥˜ ê°œì„  + ì£¼ê°€ ì •ì²´ = 80ì  (ì•„ì§ ë°œê²¬ ì•ˆë¨, ê¸°íšŒ!)
    C. ë°¸ë¥˜ ì•…í™” + ì£¼ê°€ í•˜ë½ = 10ì  (Value Trap)
    D. ë°¸ë¥˜ ì•…í™” + ì£¼ê°€ ìƒìŠ¹ = 30ì  (ë²„ë¸” ì¡°ì§)
    """

    # Step 1: í˜„ì¬ PER
    per_current_query = """
    SELECT per
    FROM kr_intraday_detail
    WHERE symbol = $1
    LIMIT 1
    """

    per_current_result = await self.execute_query(per_current_query, self.symbol)

    if not per_current_result or not per_current_result[0]['per']:
        return None

    per_current = float(per_current_result[0]['per'])

    # Step 2: 60ì¼ ì „ PER (ì—­ì‚°)
    per_60d_query = """
    WITH price_60d AS (
        SELECT close as price_60d_ago
        FROM kr_intraday_total
        WHERE symbol = $1
            AND date <= COALESCE($2::date, CURRENT_DATE) - INTERVAL '60 days'
        ORDER BY date DESC
        LIMIT 1
    ),
    latest_eps AS (
        SELECT eps
        FROM kr_intraday_detail
        WHERE symbol = $1
        LIMIT 1
    )
    SELECT
        p.price_60d_ago,
        e.eps,
        CASE
            WHEN e.eps > 0 THEN p.price_60d_ago / e.eps
            ELSE NULL
        END as per_60d_ago
    FROM price_60d p, latest_eps e
    """

    per_60d_result = await self.execute_query(per_60d_query, self.symbol, self.analysis_date)

    if not per_60d_result or not per_60d_result[0]['per_60d_ago']:
        return None

    per_60d_ago = float(per_60d_result[0]['per_60d_ago'])

    # Step 3: PER ê°œì„ ìœ¨
    if per_60d_ago > 0 and per_current > 0:
        per_improvement = (per_60d_ago - per_current) / per_60d_ago
    else:
        return None

    # Step 4: ì£¼ê°€ ìˆ˜ìµë¥  (60ì¼)
    price_return_query = """
    WITH prices AS (
        SELECT
            (SELECT close FROM kr_intraday_total
             WHERE symbol = $1 AND ($2::date IS NULL OR date = $2)
             ORDER BY date DESC LIMIT 1) as price_now,
            (SELECT close FROM kr_intraday_total
             WHERE symbol = $1 AND date <= COALESCE($2::date, CURRENT_DATE) - INTERVAL '60 days'
             ORDER BY date DESC LIMIT 1) as price_60d_ago
    )
    SELECT
        price_now,
        price_60d_ago,
        (price_now - price_60d_ago) / NULLIF(price_60d_ago, 0) as price_return
    FROM prices
    """

    price_return_result = await self.execute_query(price_return_query, self.symbol, self.analysis_date)

    if not price_return_result or price_return_result[0]['price_return'] is None:
        return None

    price_return_60d = float(price_return_result[0]['price_return'])

    # Step 5: ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
    score = 50  # ê¸°ë³¸ê°’

    # A. ë°¸ë¥˜ ê°œì„  + ì£¼ê°€ ìƒìŠ¹ = "ì‹œì¥ì´ ì¸ì •í•˜ê¸° ì‹œì‘"
    if per_improvement > 0.10 and price_return_60d > 0.05:
        score = 90
        logger.info(f"V19: Market recognizing value (PER â†“{per_improvement*100:.1f}%, Price â†‘{price_return_60d*100:.1f}%)")

    # B. ë°¸ë¥˜ ê°œì„  + ì£¼ê°€ ì •ì²´ = "ì•„ì§ ë°œê²¬ ì•ˆë¨" (ê¸°íšŒ!)
    elif per_improvement > 0.10 and -0.05 < price_return_60d < 0.05:
        score = 80
        logger.info(f"V19: Undiscovered value opportunity (PER â†“{per_improvement*100:.1f}%, Price flat)")

    # C. ë°¸ë¥˜ ì•…í™” + ì£¼ê°€ í•˜ë½ = "ì‹¤ì  ì•…í™”" (Value Trap)
    elif per_improvement < -0.10 and price_return_60d < -0.05:
        score = 10
        logger.info(f"V19: Value Trap (PER â†‘{abs(per_improvement)*100:.1f}%, Price â†“{abs(price_return_60d)*100:.1f}%)")

    # D. ë°¸ë¥˜ ì•…í™” + ì£¼ê°€ ìƒìŠ¹ = "ë²„ë¸” ì¡°ì§"
    elif per_improvement < -0.10 and price_return_60d > 0.05:
        score = 30
        logger.info(f"V19: Potential bubble (PER â†‘{abs(per_improvement)*100:.1f}%, Price â†‘{price_return_60d*100:.1f}%)")

    # E. ì†Œí­ ë³€í™”
    else:
        score = 50
        logger.info(f"V19: Neutral momentum (PER {per_improvement*100:+.1f}%, Price {price_return_60d*100:+.1f}%)")

    return score
```

**Task 2.1 ì™„ë£Œ í›„**: `calculate_all_strategies()` í•¨ìˆ˜ì—ì„œ V19 í™œì„±í™”

```python
'V19_Value_Momentum': self.calculate_v19_value_momentum(),  # âœ… í™œì„±í™”
```

---

### Task 2.2: Sector-Health-Weighted Peer-Relative êµ¬í˜„

**ëª©í‘œ**: ë§í•œ ì„¹í„° í˜ë„í‹° ë°˜ì˜

**ìˆ˜ì • íŒŒì¼**: `kr\kr_value_factor.py`

#### Step 1: Sector Health Check í•¨ìˆ˜ ì¶”ê°€

```python
async def calculate_sector_health_score(self):
    """
    ì„¹í„° ê±´ê°•ë„ í‰ê°€

    Returns:
        int: 0-100 (0=ì¬ì•™, 100=ìµœê³ )
    """

    # Step 1: ì¢…ëª©ì˜ ì„¹í„° ì¡°íšŒ
    sector_query = """
    SELECT theme
    FROM kr_stock_detail
    WHERE symbol = $1
    """

    sector_result = await self.execute_query(sector_query, self.symbol)

    if not sector_result or not sector_result[0]['theme']:
        return 50  # ì¤‘ë¦½

    sector = sector_result[0]['theme']

    # Step 2: ì„¹í„° 30ì¼ ìˆ˜ìµë¥ 
    sector_return_query = """
    WITH sector_stocks AS (
        SELECT symbol
        FROM kr_stock_detail
        WHERE theme = $1
    ),
    sector_returns AS (
        SELECT
            AVG(
                (current_price.close - past_price.close) / NULLIF(past_price.close, 0) * 100
            ) as avg_return_30d
        FROM sector_stocks ss
        JOIN kr_intraday_total current_price ON ss.symbol = current_price.symbol
        JOIN kr_intraday_total past_price
            ON ss.symbol = past_price.symbol
            AND past_price.date <= COALESCE($2::date, CURRENT_DATE) - INTERVAL '30 days'
        WHERE ($2::date IS NULL OR current_price.date = $2)
            AND current_price.close IS NOT NULL
            AND past_price.close IS NOT NULL
    )
    SELECT avg_return_30d
    FROM sector_returns
    """

    sector_return_result = await self.execute_query(sector_return_query, sector, self.analysis_date)

    if not sector_return_result or sector_return_result[0]['avg_return_30d'] is None:
        return 50

    sector_return_30d = float(sector_return_result[0]['avg_return_30d'])

    # Step 3: ì‹œì¥ ì „ì²´ 30ì¼ ìˆ˜ìµë¥ 
    market_return_query = """
    WITH market_returns AS (
        SELECT
            AVG(
                (current_price.close - past_price.close) / NULLIF(past_price.close, 0) * 100
            ) as avg_return_30d
        FROM kr_intraday_total current_price
        JOIN kr_intraday_total past_price
            ON current_price.symbol = past_price.symbol
            AND past_price.date <= COALESCE($1::date, CURRENT_DATE) - INTERVAL '30 days'
        WHERE ($1::date IS NULL OR current_price.date = $1)
            AND current_price.close IS NOT NULL
            AND past_price.close IS NOT NULL
            AND current_price.market_cap > 100000000000  -- 1ì²œì–µ ì´ìƒë§Œ
    )
    SELECT avg_return_30d
    FROM market_returns
    """

    market_return_result = await self.execute_query(market_return_query, self.analysis_date)

    market_return_30d = 0
    if market_return_result and market_return_result[0]['avg_return_30d']:
        market_return_30d = float(market_return_result[0]['avg_return_30d'])

    # Step 4: ì„¹í„° ì•ŒíŒŒ
    sector_alpha = sector_return_30d - market_return_30d

    # Step 5: ê±´ê°•ë„ ì ìˆ˜
    health_score = 50  # ê¸°ë³¸ê°’

    if sector_return_30d < -10:
        health_score = 20  # ì„¹í„° í­ë½
        logger.info(f"Sector Health: {health_score} - Sector crash ({sector_return_30d:.1f}%)")
    elif sector_alpha < -5:
        health_score = 40  # ì„¹í„° ë¶€ì§„
        logger.info(f"Sector Health: {health_score} - Sector underperforming (Î±={sector_alpha:.1f}%)")
    elif sector_return_30d > 5 and sector_alpha > 0:
        health_score = 80  # ì„¹í„° ê°•ì„¸
        logger.info(f"Sector Health: {health_score} - Sector outperforming (Î±=+{sector_alpha:.1f}%)")
    else:
        health_score = 50  # ì¤‘ë¦½
        logger.info(f"Sector Health: {health_score} - Sector neutral ({sector_return_30d:.1f}%)")

    return health_score
```

#### Step 2: V1, V3, V7, V13 í•¨ìˆ˜ ìˆ˜ì • (Peer-Relative ì ìš©)

**V1 ìˆ˜ì • ì˜ˆì‹œ**:

```python
async def calculate_v1(self):
    """
    V1. Low PER Strategy (Sector-Health-Weighted Peer-Relative)
    """

    # ... (ê¸°ì¡´ PER ê³„ì‚° ë¡œì§) ...

    # ì ì ê¸°ì—… ì²˜ë¦¬
    if per is None or per <= 0:
        logger.info(f"V1: PER invalid ({per}), falling back to V17")
        return await self.calculate_v17_growth_adjusted_value()

    # í‘ì ê¸°ì—…: Sector-Health-Weighted í‰ê°€

    # Step 1: ì„¹í„° ê±´ê°•ë„ ì²´í¬
    sector_health = await self.calculate_sector_health_score()

    # Step 2: ì„¹í„° ì¤‘ì•™ê°’ PER
    sector_per_query = """
    WITH sector_stocks AS (
        SELECT sd.symbol, sd.theme
        FROM kr_stock_detail sd
        WHERE sd.symbol = $1
    ),
    peer_pers AS (
        SELECT per
        FROM kr_intraday_detail kid
        JOIN kr_stock_detail sd ON kid.symbol = sd.symbol
        WHERE sd.theme = (SELECT theme FROM sector_stocks)
            AND kid.per > 0
            AND kid.per < 100
    )
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY per) as median_per
    FROM peer_pers
    """

    sector_per_result = await self.execute_query(sector_per_query, self.symbol)

    # Step 3: ì „ì²´ ì‹œì¥ ì¤‘ì•™ê°’ PER
    market_per_query = """
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY per) as median_per
    FROM kr_intraday_detail
    WHERE per > 0 AND per < 100
    """

    market_per_result = await self.execute_query(market_per_query)

    sector_median_per = 15  # ê¸°ë³¸ê°’
    market_median_per = 15  # ê¸°ë³¸ê°’

    if sector_per_result and sector_per_result[0]['median_per']:
        sector_median_per = float(sector_per_result[0]['median_per'])

    if market_per_result and market_per_result[0]['median_per']:
        market_median_per = float(market_per_result[0]['median_per'])

    # Step 4: Discount ê³„ì‚°
    peer_discount = (per - sector_median_per) / sector_median_per
    market_discount = (per - market_median_per) / market_median_per

    # Step 5: ì„¹í„° ê±´ê°•ë„ ê¸°ë°˜ ì ìˆ˜
    score = 50

    if sector_health >= 70:
        # ê±´ê°•í•œ ì„¹í„°: Peer-Relative ì‹ ë¢°
        if peer_discount < -0.30:
            score = 90
        elif peer_discount < -0.15:
            score = 75
        elif peer_discount < 0:
            score = 60
        else:
            score = 40
        logger.info(f"V1: Healthy sector peer-relative (PER discount: {peer_discount*100:.1f}%)")

    elif sector_health >= 40:
        # ì¤‘ë¦½ ì„¹í„°: Peer + Absolute í˜¼í•©
        peer_score = 60 if peer_discount < -0.30 else 50 if peer_discount < 0 else 35
        absolute_score = 100 - min(100, max(0, (per / 15) * 50))
        score = peer_score * 0.7 + absolute_score * 0.3
        logger.info(f"V1: Neutral sector mixed (Peer: {peer_score}, Absolute: {absolute_score:.0f})")

    else:
        # ë§í•œ ì„¹í„°: ì ˆëŒ€ í‰ê°€ + í˜ë„í‹°
        absolute_score = 100 - min(100, max(0, (per / 15) * 50))

        if market_discount < -0.50 and sector_health >= 20:
            # ë§í•œ ì„¹í„°ì§€ë§Œ ì ˆëŒ€ì ìœ¼ë¡œ ì´ˆì €í‰ê°€
            score = absolute_score * 0.8  # í˜ë„í‹° 20%
            logger.info(f"V1: Weak sector but ultra-cheap (Market discount: {market_discount*100:.1f}%)")
        else:
            score = absolute_score * 0.6  # í˜ë„í‹° 40%
            logger.info(f"V1: Weak sector penalty applied")

    return score
```

**ë™ì¼í•œ ë¡œì§ì„ V3, V7, V13ì—ë„ ì ìš©**

---

## Phase 3: ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸

### Task 3.1: VALUE_STRATEGY_WEIGHTS ë”•ì…”ë„ˆë¦¬ ì—…ë°ì´íŠ¸

**ìˆ˜ì • íŒŒì¼**:
- `kr\kr_value_factor.py` (ë¼ì¸ 40-145)
- `kr\weight.py`
- `kr\batch_weight.py`

**ìˆ˜ì • ë‚´ìš©**:

```python
VALUE_STRATEGY_WEIGHTS = {
    # Large Cap Group (6)
    'KOSPIëŒ€í˜•-í™•ì¥ê³¼ì—´-ê³µê²©í˜•': {
        'V1': 0.3,
        'V2': 0.0,   # âœ… DEPRECATED
        'V3': 1.2,
        'V4': 0.8,   # âœ… ì¬ì„¤ê³„ë¨
        'V5': 0.0,   # âœ… DEPRECATED
        'V6': 0.0,   # âœ… V20ë¡œ ëŒ€ì²´
        'V7': 0.7,
        'V8': 1.0,
        'V9': 0.0,   # âœ… V18ë¡œ ëŒ€ì²´
        'V10': 0.8,
        'V11': 0.5,
        'V12': 0.6,
        'V13': 0.8,
        'V14': 0.9,
        'V15': 0.4,
        'V16': 0.1,
        # ì‹ ê·œ ì „ëµ
        'V17': 0.5,  # âœ… ì ì ì„±ì¥ì£¼
        'V18': 0.3,  # âœ… EV/Sales/Growth (V9 ëŒ€ì²´)
        'V19': 0.7,  # âœ… Value Momentum
        'V20': 0.2,  # âœ… ROIC Value (V6 ëŒ€ì²´)
    },

    # ... (19ê°œ ì‹œì¥ ìƒíƒœ ëª¨ë‘ ë™ì¼í•˜ê²Œ ì—…ë°ì´íŠ¸)

    # Special: ì„±ì¥ì£¼ ì¤‘ì‹¬ ì‹œì¥ ìƒíƒœ
    'KOSDAQì†Œí˜•-ì„±ì¥í…Œë§ˆ-ê³ ìœ„í—˜í˜•': {
        'V1': 0.2,
        'V2': 0.0,
        'V3': 0.5,
        'V4': 0.1,
        'V5': 0.0,
        'V6': 0.0,
        'V7': 0.4,
        'V8': 0.5,
        'V9': 0.0,
        'V10': 0.5,
        'V11': 0.3,
        'V12': 0.3,
        'V13': 0.6,
        'V14': 0.2,
        'V15': 0.8,
        'V16': 1.5,
        # ì‹ ê·œ: ì„±ì¥ì£¼ì—ì„œëŠ” V17, V18ì´ ì¤‘ìš”
        'V17': 1.8,  # âœ… ì ì ì„±ì¥ì£¼ ìµœëŒ€ ê°€ì¤‘ì¹˜
        'V18': 1.2,  # âœ… ì„±ì¥ë¥  ì¡°ì • ë°¸ë¥˜
        'V19': 1.0,  # âœ… ë°¸ë¥˜ ëª¨ë©˜í…€
        'V20': 0.5,  # âœ… ROIC (ì„±ì¥ì£¼ì—ì„  ëœ ì¤‘ìš”)
    },
}
```

**ì£¼ì˜**: 19ê°œ ì‹œì¥ ìƒíƒœ ëª¨ë‘ ì—…ë°ì´íŠ¸í•´ì•¼ í•¨!

---

### Task 3.2: _get_strategy_weights() í•¨ìˆ˜ ì—…ë°ì´íŠ¸

**ìœ„ì¹˜**: `kr\kr_value_factor.py`

```python
def _get_strategy_weights(self):
    """
    Get strategy weights based on market state

    Returns dict with 20 strategy weights (V1-V16 + V17-V20)
    """

    if self.market_state and self.market_state in VALUE_STRATEGY_WEIGHTS:
        weights = VALUE_STRATEGY_WEIGHTS[self.market_state]
    else:
        # ê¸°ë³¸ ê°€ì¤‘ì¹˜
        weights = VALUE_STRATEGY_WEIGHTS['ê¸°íƒ€']

    # 20ê°œ ì „ëµ ëª¨ë‘ í¬í•¨ í™•ì¸
    expected_strategies = [f'V{i}' for i in range(1, 21)]

    for strategy in expected_strategies:
        if strategy not in weights:
            weights[strategy] = 0.5  # ê¸°ë³¸ê°’
            logger.warning(f"Strategy {strategy} not in weights, using default 0.5")

    return weights
```

---

## Phase 4: í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

### Task 4.1: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

**íŒŒì¼ ìƒì„±**: `phase3_7_value_test.py`

```python
"""
Phase 3.7 Value Strategy Test Suite
ê°œì„ ëœ ë°¸ë¥˜ ì „ëµ ê²€ì¦
"""

import asyncio
import logging
from datetime import datetime
from dotenv import load_dotenv

# Import necessary modules
try:
    from database.async_db_manager import AsyncDatabaseManager
    from kr.kr_value_factor import ValueFactorCalculator
except ImportError:
    from async_db_manager import AsyncDatabaseManager
    from kr_value_factor import ValueFactorCalculator

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ValueStrategyTester:
    """ë°¸ë¥˜ ì „ëµ ê°œì„  í…ŒìŠ¤íŠ¸"""

    def __init__(self):
        self.db_manager = None
        self.test_results = []

    async def setup(self):
        """í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •"""
        self.db_manager = AsyncDatabaseManager()
        await self.db_manager.connect()

    async def teardown(self):
        """í…ŒìŠ¤íŠ¸ í™˜ê²½ ì •ë¦¬"""
        if self.db_manager:
            await self.db_manager.close()

    async def test_v17_loss_making_stocks(self):
        """
        Test 1: ì ì ì„±ì¥ì£¼ í…ŒìŠ¤íŠ¸

        ê²€ì¦ ëŒ€ìƒ:
        - ìœ„ë‹ˆì•„ì—ì´ë“œ (ì ì, 141% ìˆ˜ìµ)
        - ì›ìµí™€ë”©ìŠ¤ (ì ì, 115% ìˆ˜ìµ)
        - ë‰´ë¡œí• (ì ì, 52% ìˆ˜ìµ)

        ê¸°ëŒ€ ê²°ê³¼:
        - V1 (PER) â†’ V17ë¡œ í´ë°±
        - V17 ì ìˆ˜ > 0 (ê¸°ì¡´: 0ì )
        - ë†’ì€ ì„±ì¥ë¥  ì¸ì‹
        """

        logger.info("\n" + "="*80)
        logger.info("TEST 1: V17 ì ì ì„±ì¥ì£¼ í…ŒìŠ¤íŠ¸")
        logger.info("="*80)

        test_stocks = [
            ('377460', 'ìœ„ë‹ˆì•„ì—ì´ë“œ', 141.28),
            ('030530', 'ì›ìµí™€ë”©ìŠ¤', 115.09),
            ('380550', 'ë‰´ë¡œí•', 51.89),
        ]

        for symbol, name, expected_return in test_stocks:
            logger.info(f"\ní…ŒìŠ¤íŠ¸: {name} ({symbol})")

            calc = ValueFactorCalculator(
                symbol=symbol,
                db_manager=self.db_manager,
                analysis_date=datetime(2025, 8, 1)
            )

            # V1 (PER) ê³„ì‚° - V17ë¡œ í´ë°±ë˜ì–´ì•¼ í•¨
            v1_score = await calc.calculate_v1()

            # V17 ì§ì ‘ ê³„ì‚°
            v17_score = await calc.calculate_v17_growth_adjusted_value()

            logger.info(f"  V1 Score: {v1_score} (V17ë¡œ í´ë°±)")
            logger.info(f"  V17 Score: {v17_score}")
            logger.info(f"  ì‹¤ì œ ìˆ˜ìµë¥ : +{expected_return:.1f}%")

            # ê²€ì¦
            assert v1_score is not None, f"{name}: V1ì´ None (ì ì ì²˜ë¦¬ ì‹¤íŒ¨)"
            assert v1_score > 0, f"{name}: V1 ì ìˆ˜ê°€ 0 (V17 í´ë°± ì‹¤íŒ¨)"
            assert v17_score is not None, f"{name}: V17ì´ None"
            assert v17_score >= 50, f"{name}: V17 ì ìˆ˜ ë„ˆë¬´ ë‚®ìŒ ({v17_score})"

            self.test_results.append({
                'test': 'V17_Loss_Making',
                'stock': name,
                'v1_score': v1_score,
                'v17_score': v17_score,
                'return': expected_return,
                'pass': v1_score > 0 and v17_score >= 50
            })

        logger.info("\nâœ… TEST 1 ì™„ë£Œ")

    async def test_v4_dividend_trap(self):
        """
        Test 2: ë°°ë‹¹ í•¨ì • í…ŒìŠ¤íŠ¸

        ê²€ì¦ ëŒ€ìƒ:
        - ìœ ì•„ì´ì—˜ (100ì  ë°›ì•˜ì§€ë§Œ -12% ì†ì‹¤)
        - ì„œí˜¸ì „ê¸° (100ì  ë°›ì•˜ì§€ë§Œ -13% ì†ì‹¤)

        ê¸°ëŒ€ ê²°ê³¼:
        - ê¸°ì¡´ V4: 100ì 
        - ì‹ ê·œ V4: <30ì  (ì§€ì† ë¶ˆê°€ëŠ¥ íƒì§€)
        """

        logger.info("\n" + "="*80)
        logger.info("TEST 2: V4 ë°°ë‹¹ í•¨ì • í…ŒìŠ¤íŠ¸")
        logger.info("="*80)

        test_stocks = [
            ('049520', 'ìœ ì•„ì´ì—˜', -12.09),
            ('065710', 'ì„œí˜¸ì „ê¸°', -12.85),
        ]

        for symbol, name, actual_return in test_stocks:
            logger.info(f"\ní…ŒìŠ¤íŠ¸: {name} ({symbol})")

            calc = ValueFactorCalculator(
                symbol=symbol,
                db_manager=self.db_manager,
                analysis_date=datetime(2025, 8, 1)
            )

            # ì‹ ê·œ V4 (ì§€ì† ê°€ëŠ¥ ë°°ë‹¹)
            v4_new_score = await calc.calculate_v4_sustainable_dividend()

            # ê¸°ì¡´ V4 (ì°¸ê³ ìš©)
            # v4_old_score = await calc.calculate_v4_original()

            logger.info(f"  V4 New Score: {v4_new_score}")
            logger.info(f"  ì‹¤ì œ ìˆ˜ìµë¥ : {actual_return:.1f}%")

            # ê²€ì¦: ë°°ë‹¹ í•¨ì •ì„ ë‚®ì€ ì ìˆ˜ë¡œ íƒì§€í•´ì•¼ í•¨
            assert v4_new_score is not None, f"{name}: V4ê°€ None"
            assert v4_new_score < 30, f"{name}: ë°°ë‹¹ í•¨ì • ë¯¸íƒì§€ (ì ìˆ˜: {v4_new_score})"

            self.test_results.append({
                'test': 'V4_Dividend_Trap',
                'stock': name,
                'v4_score': v4_new_score,
                'return': actual_return,
                'pass': v4_new_score < 30
            })

        logger.info("\nâœ… TEST 2 ì™„ë£Œ")

    async def test_v18_growth_valuation(self):
        """
        Test 3: V18 ì„±ì¥ë¥  ì¡°ì • ë°¸ë¥˜ì—ì´ì…˜

        ê²€ì¦:
        - ê³ ì„±ì¥ ê¸°ì—…ì˜ ë†’ì€ EV/Salesë¥¼ ì„±ì¥ë¥ ë¡œ ì¡°ì •
        - V9 ëŒ€ë¹„ ê³ ì„±ì¥ì£¼ ì ìˆ˜ ìƒìŠ¹ í™•ì¸
        """

        logger.info("\n" + "="*80)
        logger.info("TEST 3: V18 ì„±ì¥ë¥  ì¡°ì • ë°¸ë¥˜ì—ì´ì…˜")
        logger.info("="*80)

        # ê³ ì„±ì¥ ì¢…ëª© (ì ì ì„±ì¥ì£¼ í¬í•¨)
        test_stocks = [
            ('380550', 'ë‰´ë¡œí•'),
            ('377480', 'ë§ˆìŒAI'),
        ]

        for symbol, name in test_stocks:
            logger.info(f"\ní…ŒìŠ¤íŠ¸: {name} ({symbol})")

            calc = ValueFactorCalculator(
                symbol=symbol,
                db_manager=self.db_manager,
                analysis_date=datetime(2025, 8, 1)
            )

            v18_score = await calc.calculate_v18_ev_sales_growth()

            logger.info(f"  V18 Score: {v18_score}")

            assert v18_score is not None, f"{name}: V18ì´ None"

            self.test_results.append({
                'test': 'V18_Growth_Valuation',
                'stock': name,
                'v18_score': v18_score,
                'pass': v18_score is not None
            })

        logger.info("\nâœ… TEST 3 ì™„ë£Œ")

    async def test_v20_roic_quality(self):
        """
        Test 4: V20 ROIC ê¸°ë°˜ Quality+Value

        ê²€ì¦:
        - ë†’ì€ ROIC + ë‚®ì€ EV/IC = ë†’ì€ ì ìˆ˜
        - ë‚®ì€ ROIC + ë‚®ì€ EV/IC = ë‚®ì€ ì ìˆ˜ (Value Trap)
        """

        logger.info("\n" + "="*80)
        logger.info("TEST 4: V20 ROIC ê¸°ë°˜ Quality+Value")
        logger.info("="*80)

        # ëŒ€í˜• ìš°ëŸ‰ì£¼ í…ŒìŠ¤íŠ¸
        test_stocks = [
            ('005930', 'ì‚¼ì„±ì „ì'),
            ('000660', 'SKí•˜ì´ë‹‰ìŠ¤'),
        ]

        for symbol, name in test_stocks:
            logger.info(f"\ní…ŒìŠ¤íŠ¸: {name} ({symbol})")

            calc = ValueFactorCalculator(
                symbol=symbol,
                db_manager=self.db_manager,
                analysis_date=datetime(2025, 8, 1)
            )

            v20_score = await calc.calculate_v20_roic_value()

            logger.info(f"  V20 Score: {v20_score}")

            self.test_results.append({
                'test': 'V20_ROIC_Quality',
                'stock': name,
                'v20_score': v20_score,
                'pass': v20_score is not None
            })

        logger.info("\nâœ… TEST 4 ì™„ë£Œ")

    async def test_sector_health_check(self):
        """
        Test 5: ì„¹í„° ê±´ê°•ë„ ì²´í¬

        ê²€ì¦:
        - Finance ì„¹í„°: ê±´ê°•ë„ ë‚®ìŒ
        - IT/Semiconductor ì„¹í„°: ê±´ê°•ë„ ë†’ìŒ
        """

        logger.info("\n" + "="*80)
        logger.info("TEST 5: ì„¹í„° ê±´ê°•ë„ ì²´í¬")
        logger.info("="*80)

        test_sectors = [
            ('005930', 'ì‚¼ì„±ì „ì', 'Semiconductor', 'ë†’ìŒ'),
            ('055550', 'ì‹ í•œì§€ì£¼', 'Finance', 'ë‚®ìŒ'),
        ]

        for symbol, name, expected_sector, expected_health in test_sectors:
            logger.info(f"\ní…ŒìŠ¤íŠ¸: {name} ({expected_sector})")

            calc = ValueFactorCalculator(
                symbol=symbol,
                db_manager=self.db_manager,
                analysis_date=datetime(2025, 9, 1)
            )

            health_score = await calc.calculate_sector_health_score()

            logger.info(f"  Sector Health: {health_score}/100 (ì˜ˆìƒ: {expected_health})")

            if expected_health == 'ë†’ìŒ':
                assert health_score >= 60, f"{name}: ì„¹í„° ê±´ê°•ë„ê°€ ì˜ˆìƒë³´ë‹¤ ë‚®ìŒ"
            elif expected_health == 'ë‚®ìŒ':
                assert health_score < 60, f"{name}: ì„¹í„° ê±´ê°•ë„ê°€ ì˜ˆìƒë³´ë‹¤ ë†’ìŒ"

            self.test_results.append({
                'test': 'Sector_Health',
                'stock': name,
                'sector': expected_sector,
                'health_score': health_score,
                'pass': True
            })

        logger.info("\nâœ… TEST 5 ì™„ë£Œ")

    async def run_all_tests(self):
        """ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""

        await self.setup()

        try:
            await self.test_v17_loss_making_stocks()
            await self.test_v4_dividend_trap()
            await self.test_v18_growth_valuation()
            await self.test_v20_roic_quality()
            await self.test_sector_health_check()

            # ê²°ê³¼ ìš”ì•½
            logger.info("\n" + "="*80)
            logger.info("í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
            logger.info("="*80)

            total = len(self.test_results)
            passed = sum(1 for r in self.test_results if r.get('pass', False))

            logger.info(f"\nì´ í…ŒìŠ¤íŠ¸: {total}")
            logger.info(f"í†µê³¼: {passed}")
            logger.info(f"ì‹¤íŒ¨: {total - passed}")
            logger.info(f"í†µê³¼ìœ¨: {passed/total*100:.1f}%")

            if passed == total:
                logger.info("\nğŸ‰ ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼!")
            else:
                logger.warning("\nâš ï¸ ì¼ë¶€ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨")
                for result in self.test_results:
                    if not result.get('pass', False):
                        logger.warning(f"  ì‹¤íŒ¨: {result['test']} - {result['stock']}")

        finally:
            await self.teardown()


async def main():
    """ë©”ì¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    tester = ValueStrategyTester()
    await tester.run_all_tests()


if __name__ == '__main__':
    asyncio.run(main())
```

---

### Task 4.2: IC ì¬ê³„ì‚° ë° ë¹„êµ

**íŒŒì¼ ìƒì„±**: `phase3_7_ic_comparison.py`

```python
"""
Phase 3.7 IC Comparison
ê°œì„  ì „í›„ IC ë¹„êµ
"""

import asyncio
import logging
import pandas as pd
from datetime import datetime
from scipy.stats import spearmanr

# ... (IC ê³„ì‚° ë¡œì§)

async def compare_ic_before_after():
    """
    ê°œì„  ì „í›„ IC ë¹„êµ

    Before:
    - Value IC: -0.031
    - V1 (PER): -0.132
    - V4 (Dividend): -0.057
    - V9 (EV/Sales): +0.055

    After:
    - Value IC: ëª©í‘œ +0.02~0.05
    - V1 (PER with V17 fallback): ëª©í‘œ ì¤‘ë¦½ ì´ìƒ
    - V4 (Sustainable Dividend): ëª©í‘œ ì¤‘ë¦½ ì´ìƒ
    - V18 (EV/Sales/Growth): ëª©í‘œ +0.08 ì´ìƒ
    """

    # ... (êµ¬í˜„)
```

---

## íŒŒì¼ë³„ ìˆ˜ì • ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… kr\kr_value_factor.py

- [ ] V17 í•¨ìˆ˜ ì¶”ê°€ (ì ì ì„±ì¥ì£¼)
- [ ] V1 í•¨ìˆ˜ ìˆ˜ì • (V17 í´ë°±)
- [ ] V4 í•¨ìˆ˜ ì¬ì„¤ê³„ (ì§€ì† ê°€ëŠ¥ ë°°ë‹¹)
- [ ] V18 í•¨ìˆ˜ ì¶”ê°€ (EV/Sales/Growth)
- [ ] V20 í•¨ìˆ˜ ì¶”ê°€ (ROIC-Based Value)
- [ ] V19 í•¨ìˆ˜ ì¶”ê°€ (Value Momentum) - Phase 2
- [ ] calculate_sector_health_score() ì¶”ê°€
- [ ] V1, V3, V7, V13 Peer-Relative ìˆ˜ì • - Phase 2
- [ ] VALUE_STRATEGY_WEIGHTS ì—…ë°ì´íŠ¸ (20ê°œ ì „ëµ)
- [ ] calculate_all_strategies() ì—…ë°ì´íŠ¸
- [ ] _get_strategy_weights() ì—…ë°ì´íŠ¸

### âœ… kr\weight.py

- [ ] VALUE_STRATEGY_WEIGHTS ë™ê¸°í™”
- [ ] ì‹ ê·œ ì „ëµ ê°€ì¤‘ì¹˜ ì¶”ê°€ (V17-V20)

### âœ… kr\batch_weight.py

- [ ] VALUE_STRATEGY_WEIGHTS ë™ê¸°í™”
- [ ] ì‹ ê·œ ì „ëµ ê°€ì¤‘ì¹˜ ì¶”ê°€ (V17-V20)

### âœ… í…ŒìŠ¤íŠ¸ íŒŒì¼

- [ ] phase3_7_value_test.py ìƒì„±
- [ ] phase3_7_ic_comparison.py ìƒì„±

---

## ê²€ì¦ ê¸°ì¤€

### ê¸°ëŠ¥ ê²€ì¦

1. **V17 (ì ì ì„±ì¥ì£¼)**
   - ìœ„ë‹ˆì•„ì—ì´ë“œ, ì›ìµí™€ë”©ìŠ¤, ë‰´ë¡œí•: ì ìˆ˜ > 0
   - ê³ ì„±ì¥ ì¸ì‹ (CAGR >50%)
   - PSR ê¸°ë°˜ í‰ê°€ ì‘ë™

2. **V4 (ì§€ì† ê°€ëŠ¥ ë°°ë‹¹)**
   - ìœ ì•„ì´ì—˜, ì„œí˜¸ì „ê¸°: ì ìˆ˜ < 30 (í•¨ì • íƒì§€)
   - Payout Ratio >80% íƒì§€
   - FCF Coverage <1.0 íƒì§€

3. **V18 (EV/Sales/Growth)**
   - ê³ ì„±ì¥ì£¼ ì ìˆ˜ ìƒìŠ¹
   - ì €ì„±ì¥ì£¼ í˜ë„í‹°
   - ì„¹í„° ë‚´ ìƒëŒ€ í‰ê°€

4. **V20 (ROIC-Based)**
   - ë†’ì€ ROIC + ë‚®ì€ EV/IC = 90ì 
   - ë‚®ì€ ROIC + ë‚®ì€ EV/IC = 20ì 

5. **Sector Health**
   - Finance ì„¹í„°: <50ì 
   - IT/Semi ì„¹í„°: >70ì 

### ì„±ëŠ¥ ê²€ì¦

1. **IC ê°œì„ **
   - Value IC: -0.031 â†’ +0.02 ì´ìƒ
   - V1 IC: -0.132 â†’ ì¤‘ë¦½ ì´ìƒ
   - V4 IC: -0.057 â†’ ì¤‘ë¦½ ì´ìƒ
   - V18 IC: +0.08 ì´ìƒ (V9 +0.055 ê°œì„ )

2. **ë…¼ë¦¬ì  ì •í•©ì„±**
   - ì ì ì„±ì¥ì£¼ 0ì  â†’ í•´ê²°
   - ë°°ë‹¹ í•¨ì • 100ì  â†’ í•´ê²°
   - ë§í•œ ì„¹í„° í˜ë„í‹° â†’ í•´ê²°

---

## ì‘ì—… ì¼ì •

### Week 1
- Task 1.1: V17 ì¶”ê°€
- Task 1.2: V4 ì¬ì„¤ê³„
- Task 1.3: V18 ì¶”ê°€
- Task 1.4: V20 ì¶”ê°€

### Week 2
- Task 1.5: calculate_all_strategies ì—…ë°ì´íŠ¸
- Task 3.1: VALUE_STRATEGY_WEIGHTS ì—…ë°ì´íŠ¸
- Task 4.1: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì‹¤í–‰

### Week 3
- Task 2.1: V19 ì¶”ê°€
- Task 2.2: Sector Health + Peer-Relative êµ¬í˜„

### Week 4
- Task 4.2: IC ì¬ê³„ì‚° ë° ê²€ì¦
- ìµœì¢… ë¦¬ë·° ë° ë¬¸ì„œí™”

---

## ë¹„ìƒ ê³„íš

### ë§Œì•½ ICê°€ ê°œì„ ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´?

1. **ë¡œì§ ê²€ì¦**
   - ê³„ì‚° ì˜¤ë¥˜ í™•ì¸
   - SQL ì¿¼ë¦¬ ê²€ì¦
   - ë°ì´í„° í’ˆì§ˆ ì²´í¬

2. **íŒŒë¼ë¯¸í„° ì¡°ì •**
   - ì„ê³„ê°’ ì¬ì¡°ì •
   - ê°€ì¤‘ì¹˜ ë¯¸ì„¸ ì¡°ì •

3. **ì›ì¹™ ê³ ìˆ˜**
   - IC ë‚®ì•„ë„ ë…¼ë¦¬ì ìœ¼ë¡œ íƒ€ë‹¹í•˜ë©´ ìœ ì§€
   - ê³¼ì í•© ë°©ì§€ ìš°ì„ 

---

**ì‘ì—…ê³„íšì„œ ë²„ì „**: 1.0
**ì‘ì„±ì¼**: 2025-11-22
**ê²€í†  ì£¼ê¸°**: ì£¼ê°„
**ìµœì¢… ëª©í‘œ**: 2025-12-20 ì™„ë£Œ
